# Coding Guidelines

このドキュメントは，プログラミングとソフトウェア開発における包括的なコーディングガイドラインです．

## Clean Code

### ファイル設計（5原則）
- 1行80-120文字
- 1ファイル200-500行
- 高抽象度 → 低抽象度の順序
  - 呼び出し関数の直後に呼び出される関数を記述
- 密接に関連する概念を近い距離・関連しない概念を異なるファイルに記述
  - 同ファイルにクラスと固有の列挙型や例外クラスを定義
- オブジェクトの生成と実行を分離（依存関係を一方向にする・生成と実行の責務を分ける）
  - オブジェクトの生成・設定はmain・AbstractFactory・DIコンテナのみ

### クラス設計（10原則）

#### クラスの方針（3原則）
- クラスの責務（変更の原因）は1つ（SRP）
- フィールド・メソッドの数は最小限
  - 全メソッドが全フィールドを満遍なく使う（高凝集）
  - フィールドとメソッドの対応関係が分かれる場合クラスを分割
- フィールド・メソッドは原則private・公開する必要がある場合のみpublic

#### クラスの原則（7原則）
- クラス名が責務を表す
- メソッド順はpublic → private（高抽象度 → 低抽象度）
- 特定の領域で使用しないフィールドやメソッドを禁止
  - ユーザー定義型でないオブジェクトはラップ
  - ユーザー定義型オブジェクトはインターフェースを定義
- インターフェースを挟んで内部実装を分離（疎結合）
- 1コンセプトに1例外クラス
- 機能の羨望（他オブジェクトから他オブジェクトのメンバにアクセス）を行わない（デメテルの法則）
- コンポーネント間のやり取りはDTO（受信データを格納する責務を持つ不変なオブジェクト）

### 関数設計（10原則）

#### 関数の方針（2原則）
- 関数がたった1つのことを行う
  - 関数が2つ以上のことを行う場合分割
    - 重複を抽出
    - 段落に分けて抽出（SRP）
    - 制御構文を抽出
    - 反復処理内の異なる責務の処理を反復自体を分けて分離
    - コマンドとクエリを分けて抽出（コマンドクエリ責務分離）
- 関数の処理をより具体的な複数の関数で表現
  - 1つの関数に1つの抽象レベルを指定
  - 高抽象度 → 低抽象度となるto節の並びで読めるようにする

#### 関数の原則（8原則）
- 引数は0-3個
  - 引数が多い場合はパラメータクラス作成
  - 処理の順序を引数で表現
  - キーワード引数で情報付与
- 2-4行でインデント1つまで
- 変数の定義は使う直前（変数の寿命を縮める）
- 処理に変数を用いる場合一時変数を関数化
- 制御構文は条件・処理を関数化して2行にする
- 条件分岐は正常処理同士の分岐・正常処理と例外処理の分岐を区別
- 条件分岐の例外処理は早期に戻り値を返す（ガード節）
- 複雑なif・matchはポリモーフィズム化（Pluggable Object）

### 命名規則（8原則）

#### 命名の方針（4原則）
- 1コンセプト1単語（似た用途の命名は似る・異なる用途の命名は異なる）
- コマンド関数は副作用・クエリ関数は返すオブジェクトを命名で明確化
- 名前の長さはスコープの大きさに対応（短いスコープは名前を省略）
- 意味を持つ定数・長い式を命名（一時変数）

#### 命名の原則（4原則）
- プログラミング用語・ドメイン用語を使用
- 正確な単語選択（get・fetch・download）
- 属性の追加
  - 単位（length→chars/start_ms）
  - 接頭接尾（unsafe_・untrust_・plaintext_・_urlenc）
  - bool（is/has/can/show/should/enabled）
- 不要な単語の省略

### コメント（7原則）

#### コメントの方針(4原則)
- コメントを最小限にする（秀逸なコード > コメント）
- 公開APIでない限りdocstring不要
- コードで表現不可能な意図の説明
- コードの欠陥（TODO）

#### コメント内容（5原則）
- 動作を高レベルで説明
- 処理の正確な記述
- 情報密度の高い用語
- 曖昧な代名詞を避ける
- 入出力の秀逸な実例

## Test Driven Development (TDD)

### ルール
- テストが失敗した場合のみ新しいコードを書きその間は新しいテストを書かない
- 重複を除去

### 手順
1. TODOリストを書く
2. テストを1つ書く（テストが実行できない場合最小限の空実装を書く）
3. 全てのテストを実行して1つの失敗を確認（Red）
4. テストが成功する最小限の変更
5. 全てのテストを実行して成功を確認（Green）
6. 重複を除去（Refactoring）

### テスト設計原則

#### テストの方針（7原則）
- 自分のコードのみテストを書く
- 1コンセプト1テスト関数
- 読みやすさ最優先（長い名前・メンタルマッピングを許容）
- テスト同士を独立化
- 上手く機能しないテストは一旦消して引き返す
- 新機能追加時やバグ修正時には必ず単体テストを追加
- カバレッジはエッジケースやエラーも含めてテスト

#### テストの規則（7原則）
- 複雑なpublicメソッドにのみテストを書く
- テストの対象を操作・制御構文・ポリモーフィズムに絞る
- テスト関数名はテストが書かれた理由にする
- テストメソッドは3行まで
- アサーションを最初に書く（アサーションファースト）
- テストする処理を書く（Act）
- 必要なオブジェクトを作る（Arrange）

## リファクタリング

### 手順
1. テストを書く
2. 作業を小さく分割してリファクタリング
3. リファクタリングが成功する度にcommit

### リファクタリングタイミング（15項目）
- 不正確な名前
- 重複したコード
- パラメータ数が多い関数
- グローバルなオブジェクト
- 同形式の制御構文
- 複数の責務・分散した責務を持つ・責務のない変数，関数，クラス，モジュール
- 高凝集低結合でないクラス・モジュール
- 上位型のメソッドが必要ない継承
- プリミティブ型の濫用
- 同じクラスでないオブジェクト群
- mutableオブジェクト
- getter・setter以外にメソッドを持たないデータクラス
- 関数に見えるオブジェクトのメソッドが返すオブジェクトへの操作を行う関数
- 不吉な臭いを隠すコメント

### リファクタリングの原則（4原則）
- 機能の追加とリファクタリングを区別
- リファクタリングによるトレードオフを意識
- パフォーマンスを意識する場合まずチューニングしやすく作り段階的に速くする
- 外部の振る舞いを変更しないカプセル化が重要

## 設計原則

### SOLID原則

#### 単一責任の原則（SRP）
- モジュールが単一の役割を持つ
- 役割の異なるモジュールは分割

#### 開放閉鎖の原則（OCP）
- モジュールを変更せず拡張可能
- 変更の影響を受けないようにコンポーネントをレベル階層に分ける

#### リスコフの置換原則（LSP）
- 上位型を部分型に置換可能
- 上位型の全性質を部分型が持っている必要がある

#### インターフェース分離の原則（ISP）
- 上位型が持つ，部分型が利用しないメソッドと部分型を分離
- 役割毎のインターフェースで各メソッドの依存関係をなくす

#### 依存関係逆転の原則（DIP）
- 部分型が上位具象型ではなくインターフェースに依存
- 変化しやすい具象型を参照しない

### DRY原則（Don't Repeat Yourself）
- 重複部分を抽象化して排除

### YAGNI原則（You aren't going to need it）
- 今必要な機能のみ実装

### F.I.R.S.T（クリーンテストの条件）
- Fast（高速）
- Independent（独立）
- Repeatable（再現可能）
- Self-Validating（自己検証可能）
- Timely（適時性）

### ケント・ベックの単純な設計のための4つの規則
- 全テストを実行
- 重複がない
- プログラマの意図が表現
- クラスとメソッドの数を最小化

### デメテルの法則
- 関数は，関数から見えているオブジェクトのメソッドのみを使用するべき
- そのオブジェクトのメソッドが返すオブジェクトの内部について知るべきではない

### ボーイスカウトの規則
- 読んだコードを読む前よりもきれいにすること

### Domain Driven Design (DDD)

#### DDD実装パターン（軽量DDD）

##### ドメインモデル
- 小さな対象領域を独立したオブジェクトのモデルとして整理したモデル
- 機能からでなく関心事からドメインモデル作成
  - 機能の一部として作らない（機能中心に設計して依存関係が生まれる）
  - 年齢を知りたいという関心事 → 計算するロジックを置く場所として年齢クラス作成

##### ドメインオブジェクト
- 小さな対象領域のデータとプロセスをまとめたオブジェクト
- 非プリミティブ型を用いて必要な制約・関連メソッドのみを持つオブジェクトを設計

##### Value Object
- 値への制約と関連メソッドを持つオブジェクト（データの種類毎に作成）
- フィールドは不変（コンストラクタでフィールドを定義してsetterを作らない）
- プリミティブ型に制約を課す（int: -21億~21億の範囲・str: 無限長で形式自由・…）
- フィールドが全て等しい同型のValue Objectを同一とみなす

##### Entity
- 識別子が等しい同型のValue Objectを同一とみなす可変なValue Object

##### Collection Object
- コレクションへの制約と関連メソッドを持つオブジェクト
- コレクションそのもののgetterは作らず内部のコレクションを閉じ込める
- getterを作る場合必要な要素を取り出すメソッドのみを作る
- setterを作る場合結果を同じ型の新しいCollection Objectで返す

##### 区分オブジェクト
- 列挙型を用いた区分毎のクラス・オブジェクトを持つオブジェクト
- 区分毎のクラス・オブジェクトをフィールドに持ちインターフェースのメソッドを持つ
- 状態遷移の制約を"遷移元": set("遷移先", …)と表し遷移可能かどうかなどを判定可能
- インターフェースで同一視可能なクラス・オブジェクトを扱う場合は区分オブジェクト
- インターフェースで利用制限したオブジェクトをクラスに注入する場合はDI（依存性注入）

## その他の重要な概念

### オブジェクト指向プログラミング（OOP）
- カプセル化：データとプロセスを閉じ込めて外部からの直接アクセスを制限
- ポリモーフィズム：異なるクラスのオブジェクトに同じメソッドを持たせること
- 継承：基本的に非推奨，適切なユースケースでのみ使用

### 関数型プログラミング（FP）
- 変数不変性：変数の値を変更不可能
- 参照透過性：副作用をなくす
- 関数のオブジェクト化：関数をオブジェクトとして扱う
- 遅延評価：演算の実行直前に必要な値の処理を実行

### アーキテクチャ
- 方針と詳細を切り離す
- DBやWebサーバなどの決定を遅延して抽象的にし依存性を低くする
- 優れたアーキテクトは決定しない数を最小化する

## まとめ

このガイドラインは，保守性・拡張性・テスト容易性を重視したコード品質の向上を目指しています．全ての原則を厳格に適用するのではなく，プロジェクトの性質やチームの状況に合わせて適切に適用することが重要です．
