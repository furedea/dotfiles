{"type":"summary","summary":"Local Command Exit with No Output","leafUuid":"74ee5ca0-34af-4668-9740-0d2715e2d79d"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"65df9ea8-db2f-4d19-be9a-249e2e2e7428","timestamp":"2025-06-11T01:22:55.822Z"}
{"parentUuid":"65df9ea8-db2f-4d19-be9a-249e2e2e7428","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":"<command-name>mcp</command-name>\n            <command-message>mcp</command-message>\n            <command-args></command-args>"},"uuid":"7bc864bc-0aa4-4ee8-a398-548c657136a6","timestamp":"2025-06-11T01:23:26.108Z"}
{"parentUuid":"7bc864bc-0aa4-4ee8-a398-548c657136a6","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":"<local-command-stdout>(no content)</local-command-stdout>"},"uuid":"feb691a0-828b-4d95-ace7-6197c80696cb","timestamp":"2025-06-11T01:23:26.108Z"}
{"parentUuid":"feb691a0-828b-4d95-ace7-6197c80696cb","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":"ObsidianからCoding Guidelineの概要を要約してください．"},"uuid":"3e648fa3-1a23-4a9a-aa9a-0615105c31c9","timestamp":"2025-06-11T01:23:57.477Z"}
{"parentUuid":"3e648fa3-1a23-4a9a-aa9a-0615105c31c9","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01JRmkTfZ6rBbXGnN1MQSBQz","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I'll help you summarize the Coding Guidelines from Obsidian. Let me search for and retrieve the relevant content."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":17376,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CQ1ZShaGsArfgD94Z9fXG","type":"assistant","uuid":"c73d1ab7-431c-44f2-97b2-5082e9dd4ff5","timestamp":"2025-06-11T01:24:01.795Z"}
{"parentUuid":"c73d1ab7-431c-44f2-97b2-5082e9dd4ff5","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01JRmkTfZ6rBbXGnN1MQSBQz","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_013DTPby9wwp5KQyT6aTtyAv","name":"mcp__obsidian-mcp-tools__search_vault_simple","input":{"query":"Coding Guidelines"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":17376,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CQ1ZShaGsArfgD94Z9fXG","type":"assistant","uuid":"f790fc60-a0b2-4e3a-8abb-895a33cdc9d4","timestamp":"2025-06-11T01:24:02.297Z"}
{"parentUuid":"f790fc60-a0b2-4e3a-8abb-895a33cdc9d4","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013DTPby9wwp5KQyT6aTtyAv","type":"tool_result","content":[{"type":"text","text":"[]"}]}]},"uuid":"9b03631e-7318-45fc-be7d-c4da9bab8427","timestamp":"2025-06-11T01:24:15.987Z","toolUseResult":[{"type":"text","text":"[]"}]}
{"parentUuid":"9b03631e-7318-45fc-be7d-c4da9bab8427","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01SKNLdARNYT2oKaqcKXcHX5","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01M8Hvvsj79iTubN6Le1n7tr","name":"mcp__obsidian-mcp-tools__search_vault_simple","input":{"query":"coding guide"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":106,"cache_read_input_tokens":17376,"output_tokens":37,"service_tier":"standard"}},"requestId":"req_011CQ1ZU4UenN2b8KGw4KfFg","type":"assistant","uuid":"cde09a04-bfa9-4797-b8f2-270e447f2b3c","timestamp":"2025-06-11T01:24:19.112Z"}
{"parentUuid":"cde09a04-bfa9-4797-b8f2-270e447f2b3c","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M8Hvvsj79iTubN6Le1n7tr","type":"tool_result","content":[{"type":"text","text":"[\n  {\n    \"filename\": \"Programming.md\",\n    \"score\": -1.1975,\n    \"matches\": [\n      {\n        \"match\": {\n          \"start\": 148,\n          \"end\": 154\n        },\n        \"context\": \"\"\n      },\n      {\n        \"match\": {\n          \"start\": 155,\n          \"end\": 160\n        },\n        \"context\": \"\"\n      }\n    ]\n  }\n]"}]}]},"uuid":"b4d18174-5bae-4d0c-9c13-2998ebcd1199","timestamp":"2025-06-11T01:24:29.948Z","toolUseResult":[{"type":"text","text":"[\n  {\n    \"filename\": \"Programming.md\",\n    \"score\": -1.1975,\n    \"matches\": [\n      {\n        \"match\": {\n          \"start\": 148,\n          \"end\": 154\n        },\n        \"context\": \"\"\n      },\n      {\n        \"match\": {\n          \"start\": 155,\n          \"end\": 160\n        },\n        \"context\": \"\"\n      }\n    ]\n  }\n]"}]}
{"parentUuid":"b4d18174-5bae-4d0c-9c13-2998ebcd1199","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01LA47qTtSbUB7cb5Rg8ryyy","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_016s7HQo4Ug8ch8DmKQBH5Kx","name":"mcp__obsidian-mcp-tools__get_vault_file","input":{"filename":"Programming.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":190,"cache_read_input_tokens":17482,"output_tokens":38,"service_tier":"standard"}},"requestId":"req_011CQ1ZV6A8rTMgCE8K74nXV","type":"assistant","uuid":"980630e3-587a-4b2e-a5db-af5799efda08","timestamp":"2025-06-11T01:24:33.133Z"}
{"parentUuid":"980630e3-587a-4b2e-a5db-af5799efda08","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016s7HQo4Ug8ch8DmKQBH5Kx","type":"tool_result","content":[{"type":"text","text":"# Main Programming Language\n- [[Python(AI)(未)]]\n- [[Rust(Low)(未)]]\n- [[Dart(Mobile)(未)]]\n- [[TypeScript(Frontend)(未)]]\n\n# Knowledge\n- [[Basis]]\n- [[Coding Guideline]]\n- [[Machine Learning]]\n\n# Tools\n- [[PC]]\n- [[Terminal]]\n- [[VSCode]]\n- [[Neovim]]\n- [[Obsidian]]\n- [[Source Control]]\n- [[Container]]\n- [[Database]]\n- [[Cloud]]\n\n\n## Other Language\n- [[Markdown]]\n- [[PlantUML]]\n- [[C++(Low)(未)]]"}]}]},"uuid":"d09794e1-253b-4b30-bbf5-d4beed8273a7","timestamp":"2025-06-11T01:24:51.959Z","toolUseResult":[{"type":"text","text":"# Main Programming Language\n- [[Python(AI)(未)]]\n- [[Rust(Low)(未)]]\n- [[Dart(Mobile)(未)]]\n- [[TypeScript(Frontend)(未)]]\n\n# Knowledge\n- [[Basis]]\n- [[Coding Guideline]]\n- [[Machine Learning]]\n\n# Tools\n- [[PC]]\n- [[Terminal]]\n- [[VSCode]]\n- [[Neovim]]\n- [[Obsidian]]\n- [[Source Control]]\n- [[Container]]\n- [[Database]]\n- [[Cloud]]\n\n\n## Other Language\n- [[Markdown]]\n- [[PlantUML]]\n- [[C++(Low)(未)]]"}]}
{"parentUuid":"d09794e1-253b-4b30-bbf5-d4beed8273a7","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01YNdDniN1GyTb1Ut7Yj5PDi","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_018uvzLhSjpu4hveDjtAouPR","name":"mcp__obsidian-mcp-tools__get_vault_file","input":{"filename":"Coding Guideline.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":236,"cache_read_input_tokens":17672,"output_tokens":42,"service_tier":"standard"}},"requestId":"req_011CQ1ZWiZusWLCVxPtJh3EW","type":"assistant","uuid":"e5505ac1-ac3a-45c9-8a45-3ae7e2f3be20","timestamp":"2025-06-11T01:24:55.113Z"}
{"parentUuid":"e5505ac1-ac3a-45c9-8a45-3ae7e2f3be20","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"MCP error -32603: MCP error -32603: GET /vault/Coding%20Guideline.md 404: {\n  \"message\": \"Not Found\",\n  \"errorCode\": 40400\n}","is_error":true,"tool_use_id":"toolu_018uvzLhSjpu4hveDjtAouPR"}]},"uuid":"03322454-384e-41dc-92b1-e601841fad90","timestamp":"2025-06-11T01:24:55.141Z","toolUseResult":"Error: MCP error -32603: MCP error -32603: GET /vault/Coding%20Guideline.md 404: {\n  \"message\": \"Not Found\",\n  \"errorCode\": 40400\n}"}
{"parentUuid":"03322454-384e-41dc-92b1-e601841fad90","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01Dabdw1sFWsPPfS2pXAV7B1","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01GEBczwTUveju8XcLd9ffLr","name":"mcp__obsidian-mcp-tools__search_vault_simple","input":{"query":"guideline"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":142,"cache_read_input_tokens":17908,"output_tokens":37,"service_tier":"standard"}},"requestId":"req_011CQ1ZWwur7SSirrixwD9DQ","type":"assistant","uuid":"5e42917d-aa5a-486f-9d4e-d3f8b9d2724d","timestamp":"2025-06-11T01:24:58.601Z"}
{"parentUuid":"5e42917d-aa5a-486f-9d4e-d3f8b9d2724d","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GEBczwTUveju8XcLd9ffLr","type":"tool_result","content":[{"type":"text","text":"[\n  {\n    \"filename\": \"Programming.md\",\n    \"score\": -0.20450000000000002,\n    \"matches\": [\n      {\n        \"match\": {\n          \"start\": 155,\n          \"end\": 164\n        },\n        \"context\": \"\"\n      }\n    ]\n  }\n]"}]}]},"uuid":"a8cd07f5-e3e8-49b7-9fd5-fa558ec0274e","timestamp":"2025-06-11T01:25:09.766Z","toolUseResult":[{"type":"text","text":"[\n  {\n    \"filename\": \"Programming.md\",\n    \"score\": -0.20450000000000002,\n    \"matches\": [\n      {\n        \"match\": {\n          \"start\": 155,\n          \"end\": 164\n        },\n        \"context\": \"\"\n      }\n    ]\n  }\n]"}]}
{"parentUuid":"a8cd07f5-e3e8-49b7-9fd5-fa558ec0274e","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01N5xUGFSjqmwkY1ASyeq1Qw","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_019cWf8MRWE1W9frKWn9tLad","name":"mcp__obsidian-mcp-tools__list_vault_files","input":{}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":159,"cache_read_input_tokens":18050,"output_tokens":40,"service_tier":"standard"}},"requestId":"req_011CQ1ZY2ctaSzQW3CyBp4wA","type":"assistant","uuid":"45fdc53f-ffe2-47b1-8402-bc277b3f34da","timestamp":"2025-06-11T01:25:13.697Z"}
{"parentUuid":"45fdc53f-ffe2-47b1-8402-bc277b3f34da","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019cWf8MRWE1W9frKWn9tLad","type":"tool_result","content":[{"type":"text","text":"{\n  \"files\": [\n    \"Images/\",\n    \"Programming.md\",\n    \"Programming/\",\n    \"others/\"\n  ]\n}"}]}]},"uuid":"8f72b312-f104-4b22-8135-bba9f5b92b5c","timestamp":"2025-06-11T01:25:23.224Z","toolUseResult":[{"type":"text","text":"{\n  \"files\": [\n    \"Images/\",\n    \"Programming.md\",\n    \"Programming/\",\n    \"others/\"\n  ]\n}"}]}
{"parentUuid":"8f72b312-f104-4b22-8135-bba9f5b92b5c","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01Qs96anRmswc7PSM6s4dQoX","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01RcDBFv9b16xG2d3i3ciVnh","name":"mcp__obsidian-mcp-tools__list_vault_files","input":{"directory":"Programming"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":97,"cache_read_input_tokens":18209,"output_tokens":67,"service_tier":"standard"}},"requestId":"req_011CQ1ZZ23wdYiDWPdyQfdhr","type":"assistant","uuid":"d5106c66-21ec-4835-bbe0-00d70f95807c","timestamp":"2025-06-11T01:25:26.287Z"}
{"parentUuid":"d5106c66-21ec-4835-bbe0-00d70f95807c","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RcDBFv9b16xG2d3i3ciVnh","type":"tool_result","content":[{"type":"text","text":"{\n  \"files\": [\n    \"Knowledge/\",\n    \"Language/\",\n    \"Tool/\"\n  ]\n}"}]}]},"uuid":"f8b741d2-46ed-4684-ad6b-73bdb0d155a6","timestamp":"2025-06-11T01:25:26.307Z","toolUseResult":[{"type":"text","text":"{\n  \"files\": [\n    \"Knowledge/\",\n    \"Language/\",\n    \"Tool/\"\n  ]\n}"}]}
{"parentUuid":"f8b741d2-46ed-4684-ad6b-73bdb0d155a6","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01JTazSXPkUkVZqfSC7qKzcL","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01S3J3NrG2ak9ZhATbRYeYoL","name":"mcp__obsidian-mcp-tools__list_vault_files","input":{"directory":"Programming/Knowledge"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":107,"cache_read_input_tokens":18306,"output_tokens":69,"service_tier":"standard"}},"requestId":"req_011CQ1ZZF8VpMLx2F64Q1gpt","type":"assistant","uuid":"06a38943-0016-4ceb-811c-046eadf78022","timestamp":"2025-06-11T01:25:29.941Z"}
{"parentUuid":"06a38943-0016-4ceb-811c-046eadf78022","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S3J3NrG2ak9ZhATbRYeYoL","type":"tool_result","content":[{"type":"text","text":"{\n  \"files\": [\n    \"Basis.md\",\n    \"Coding Guideline.md\",\n    \"Machine Learning.md\"\n  ]\n}"}]}]},"uuid":"f4503b3d-3923-4d16-a15b-210fa0178d5f","timestamp":"2025-06-11T01:25:29.960Z","toolUseResult":[{"type":"text","text":"{\n  \"files\": [\n    \"Basis.md\",\n    \"Coding Guideline.md\",\n    \"Machine Learning.md\"\n  ]\n}"}]}
{"parentUuid":"f4503b3d-3923-4d16-a15b-210fa0178d5f","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_01Fs3uEZuRfNnRgVLwdrsmSj","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_016Y3MFxShZ8Kh1hqpcXGChN","name":"mcp__obsidian-mcp-tools__get_vault_file","input":{"filename":"Programming/Knowledge/Coding Guideline.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":119,"cache_read_input_tokens":18413,"output_tokens":38,"service_tier":"standard"}},"requestId":"req_011CQ1ZZWfPbj81rPRyW1ZcU","type":"assistant","uuid":"15ddcbf7-4bc8-46b5-afc0-ddff76b9d9b2","timestamp":"2025-06-11T01:25:33.881Z"}
{"parentUuid":"15ddcbf7-4bc8-46b5-afc0-ddff76b9d9b2","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016Y3MFxShZ8Kh1hqpcXGChN","type":"tool_result","content":[{"type":"text","text":"# Clean Code\n\n## ファイル(5)\n- 1行80-120文字\n- 1ファイル200-500行\n- 高抽象度 → 低抽象度\n    - 呼び出し関数の直後に呼び出される関数を記述\n- 密接に関連する概念を近い距離・関連しない概念を異なるファイルに記述\n    - 同ファイルにクラスと固有の列挙型や例外クラスを定義\n- オブジェクトの生成と実行を分離(依存関係を一方向にする・生成と実行の責務を分ける)\n    - オブジェクトの生成・設定はmain・AbstractFactory・DIコンテナのみ\n        - DIコンテナ　　(Dependency Injection)コンストラクタを通してクラスに依存性注入\n        - 部分型が変化しやすい上位具象型ではなくインターフェースに依存するようにする\n            - 生成する場合変化しやすい具象型を参照するため生成・設定専用モジュールを用意\n            - 具象型を参照するコードを分離して変更に強くする(OCP)\n\t\t\t\n## クラス(10)\n\n### クラスの方針(3)　　クラスを小さくする\n- クラスの責務(変更の原因)は1つ(SRP)\n- フィールド・メソッドの数は最小限(2)\n    - 全メソッドが全フィールドを満遍なく使う(高凝集)\n    - フィールドとメソッドの対応関係が分かれる場合クラスを分割\n- フィールド・メソッドは原則private・公開する必要がある場合のみpublic\n\n### クラスの原則(7)\n- クラス名が責務を表す\n- メソッド順はpublic → private(高抽象度 → 低抽象度)\n- 特定の領域で使用しないフィールドやメソッドを禁止(2)\n    - ユーザー定義型でないオブジェクトはラップ\n        - 組み込みコレクションをラップして使用しないメソッドを禁止\n        - 外部ライブラリのオブジェクトとエラーをラップして仕様変更の影響をなくす\n    - ユーザー定義型オブジェクトはインターフェースを定義\n- インターフェースを挟んで内部実装を分離(疎結合)\n- 1コンセプトに1例外クラス\n    - メッセージでエラーを判別(例外を分けて処理する場合を除く)\n    - Argsクラスの例外をArgsExceptionにまとめエラーに関するコードを移動(テスト容易性)\n- 機能の羨望(他オブジェクトから他オブジェクトのメンバにアクセス)を行わない(デメテルの法則)\n- コンポーネント間のやり取りはDTO(受信データを格納する責務を持つ不変なオブジェクト)\n\n## 関数(10)\n\n### 関数の方針(2)　　関数を小さくする\n- 関数がたった1つのことを行う\n    - 関数が2つ以上のことを行う場合分割(5)\n        - 重複を抽出\n        - 段落に分けて抽出(SRP)\n        - 制御構文を抽出\n        - 反復処理内の異なる責務の処理を反復自体を分けて分離\n        - コマンドとクエリを分けて抽出(コマンドクエリ責務分離)\n            - コマンド関数は副作用があり戻り値を返さない\n                - コマンド関数を分離して純粋関数を増やす(テスト容易性)\n            - クエリ関数は副作用がなく戻り値を返す\n- 関数の処理をより具体的な複数の関数で表現(2)\n    - 1つの関数に1つの抽象レベルを指定\n        - .append(低抽象度)・get_html(高抽象度)\n    - 高抽象度 → 低抽象度となるto節の並びで読めるようにする\n        - 内容を取り込むため開始内容と終了内容を取り込む→開始内容を取り込むため…\n\t\t\n### 関数の原則(8)\n- 引数は0-3個(2)\n    - 引数が多い場合はパラメータクラス作成\n    - 処理の順序を引数で表現\n        - gradient = saturate_gradient(); reticulate_splines(gradient);\n    - キーワード引数で情報付与\n        - initialize_parameters(n_features=X.shape[1])\n- 2-4行でインデント1つまで\n- 変数の定義は使う直前(変数の寿命を縮める)\n- 処理に変数を用いる場合一時変数を関数化\n    - circle_square = PI * (radius**2) → circle_square(radius)\n- 制御構文は条件・処理を関数化して2行にする\n- 条件分岐は正常処理同士の分岐・正常処理と例外処理の分岐を区別\n    - 条件は肯定・単純・目立つ条件を原則先にする\n    - 比較は左に変化する比較対象\n- 条件分岐の例外処理は早期に戻り値を返す(ガード節)\n    - else節を最小限にする\n- 複雑なif・matchはポリモーフィズム化(Pluggable Object)\n\n## 命名(8)\n\n### 命名の方針(4)　　良い命名が浮かんだ場合積極的に変更\n- 1コンセプト1単語(似た用途の命名は似る・異なる用途の命名は異なる)\n    - DeviceManagerがある場合　ProtocolController→ProtocolManager\n    - .add(book)**≒**add(customer)がある場合　.add(book, index)→.insert(book, index)\n- コマンド関数は副作用・クエリ関数は返すオブジェクトを命名で明確化\n- 名前の長さはスコープの大きさに対応(短いスコープは名前を省略)\n    - Args.ArgumentMarshaler am = booleanArgs.get(arg);\n- 意味を持つ定数・長い式を命名(一時変数)\n    - THREE_DIGITS_PI = 3.14; circle_square = THREE_DIGITS_PI * (radius**2);\n\t\n### 命名の原則(4)　　意図が明確な場合命名は短い方が良い\n- プログラミング用語・ドメイン用語を使用　ex: job_queue\n- 正確な単語選択(get・fetch・download)　ex: get　軽量アクション\n- 属性の追加(3)\n    - 単位(length→chars/start_ms)\n    - 接頭接尾(3)　ex: unsafe_・untrust_・plaintext_・_urlenc\n        - 最大最小　min・max\n        - 範囲(以上以下)　　first・last\n        - 包含排他(以上未満)　　start・end\n    - bool(6)　肯定形\n        - is(状態)\n        - has(所有)\n        - can(可能性)\n        - show(表示)\n        - should(行動の推奨)\n        - enabled(機能のオンオフ)\n- 不要な単語の省略　ex: convert_to_string→to_string　money_amount→money\n\n## コメント(7)　　コードで伝えられない意図を知らせる\n\n### コメントの方針(2)　　コメントを最小限にする(秀逸なコード > コメント)\n公開APIでない限りdocstring不要(コードとともにコメントを修正するのはDRY原則違反)\n- コードで表現不可能な意図の説明　ex: 自明でないアルゴリズム\n    - \\# このデータだとハッシュツリーよりもバイナリツリーの方が40%速かった\n    - NUM_THREADS = 8 # ≥ 2 * num_processesで十分\n- コードの欠陥　ex: # TODO(name): もっと高速なアルゴリズムを使う\n\n### コメント内容(5)　　正確に簡潔に記述\n- 動作を高レベルで説明\n- 処理の正確な記述　ex: 行 → \\n\n- 情報密度の高い用語　ex: 正規化\n- 曖昧な代名詞を避ける\n- 入出力の秀逸な実例\n\n# Test Driven Development(TDD)\nテストコードと実装コードを同時に書くことで実装と改善を繰り返す開発手法\n- ≠ テストファースト　　テストするコードを書く前にテストを書く\n\n## ルール(2)\n- テストが失敗した場合のみ新しいコードを書きその間は新しいテストを書かない\n- 重複を除去\n\n## 手順(5)\n- TODOリストを書く\n    \n    ```Python\n    # test_money.py\n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    # TODO: $5 * 2 = $10\n    ```\n    \n- テストを1つ書く(テストが実行できない場合最小限の空実装を書く)\n    \n    ```Python\n    # test_money.py\n    from src import money\n    \n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    \n    \n    # TODO: $5 * 2 = $10\n    # TODO: amountをprivateにする\n    # TODO:  Dollarの副作用\n    # TODO: Moneyの丸め処理\n    class TestMoney:\n        def test_multiply_dollar(self) -> None:\n            five_dollar = money.Dollar(5) # Error\n            five_dollar.times(2)\n            assert five_dollar.amount == 10\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        amount: int\n    \n        def __init__(self, amount: int) -> None:\n            ...\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n- 全てのテストを実行して1つの失敗を確認(Red)\n    \n    ```Python\n    # test_money.py\n    from src import money\n    \n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    \n    \n    # TODO: $5 * 2 = $10\n    # TODO: amountをprivateにする\n    # TODO:  Dollarの副作用\n    # TODO: Moneyの丸め処理\n    class TestMoney:\n        def test_multiply_dollar(self) -> None:\n            five_dollar = money.Dollar(5)\n            five_dollar.times(2)\n            assert five_dollar.amount == 10 # Red\n    ```\n    \n- テストが成功する最小限の変更\n    \n    ```Python\n    # money.py\n    class Dollar:\n        amount: int = 10 # テストが成功する最小限の変更\n    \n        def __init__(self, amount: int) -> None:\n            ...\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n- 全てのテストを実行して成功を確認(Green)\n    \n    ```Python\n    # test_money.py\n    from src import money\n    \n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    \n    \n    # TODO: $5 * 2 = $10\n    # TODO: amountをprivateにする\n    # TODO:  Dollarの副作用\n    # TODO: Moneyの丸め処理\n    class TestMoney:\n        def test_multiply_dollar(self) -> None:\n            five_dollar = money.Dollar(5)\n            five_dollar.times(2)\n            assert five_dollar.amount == 10 # Green\n    ```\n    \n- 重複を除去(Refactoring)\n    \n    ```Python\n    # money.py\n    class Dollar:\n        amount: int = 5 * 2 # テストの5と2との重複\n    \n        def __init__(self, amount: int) -> None:\n            ...\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = 5 * 2\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount * 2 # 5の重複の削除\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount\n    \n        def times(self, multiplier: int) -> None:\n            self.amount = self.amount * 2\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount\n    \n        def times(self, multiplier: int) -> None:\n            self.amount = self.amount * multiplier　# 2の重複の除去\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount\n    \n        def times(self, multiplier: int) -> None:\n            self.amount *= multiplier # self.amountの重複の除去\n    ```\n    \n## TODOリスト(7)　　実装する最小単位のテストの集まり\n\n### TODOリストに書くテスト(5)\n- 実装しなければならないテスト　ex: $5 + 10 CHF = $10\n- 大きいテストのための最小単位のテスト　ex: $5 + 10 CHF = $10 → Francの掛け算が最小単位\n    - 大きい設計を考える場合まず手前にある小さな設計に着手\n- 疑問・問題点のリファクタリング　ex: 0や空文字列の場合の動作・掛け算の副作用\n- リファクタリングで欲しかったテスト\n- 言語仕様や外部ライブラリの仕様を確認するテスト(学習テスト)\n    - 新バージョンに対しての動作確認が可能\n\t\n### テストの選び方(2)\n- 最も単純なテスト\n- 次のテストに活かせるテスト\n    - 最初は抽象度が高いアプリケーションテストを書く\n        - socketが書き込まれた文字列を返せるかのテスト(後に文字列についてのテストが可能)\n\t\t\n## テスト(14)　　コードの動作を保証する手段\n\n### テストの方針(7)\n- 自分のコードのみテストを書く(他のコードを信頼できない理由がある場合を除く)\n- 1コンセプト1テスト関数\n- 読みやすさ最優先(長い名前・メンタルマッピング(ex: hbChl, …)を許容)\n- テスト同士を独立化(テストの成否が他テストの結果に影響せず好きな順序で実行可能)\n- 上手く機能しないテストは一旦消して引き返す\n- 個人作業終了時は失敗したままのテストを書いておく(次の作業への手がかりにする)\n- テスト量はプロダクトの推定寿命による\n\n### テストの規則(7)\n- 複雑なpublicメソッドにテストを書く\n    - 内部でのみ使うprivateな振る舞いの正しさも保証・単純なpublicメソッドは省略\n- テストの対象を操作・制御構文・ポリモーフィズムに絞る\n- テスト関数名はテストが書かれた理由にする\n- テストメソッドは3行まで\n- アサーションを最初に書く(アサーションファースト)(Assert)(4)\n    - アサーションは原則1つ\n        - 強く関連したアサーションは2つ以上にする(2つ目が検証されない場合がある)\n    - 適切なデータを選ぶ(3)\n        - 意味のある単純なデータ(1つの値が1つの意味を持つ)　ex: 1 + 1 → 1 + 2(順番を明確化)\n        - 明示的なデータ　ex: RATE → 2, COMMISION → 0.015, 49.25 → 100 / 2 * (1 - 0.015)\n        - 本物に近いデータ\n    - 条件を具体化　ex: assert rectangle.area() != 0 → assert rectangle.area() == 1\n    - メソッドの順序は記録用文字列を加算(Log String)\n        - assert test.log == “setup testmethod teardown “\n- テストする処理を書く(Act)(2)\n    - テストする処理は1-2行\n    - コレクションの操作は単数の操作をテストした後コレクションでも動くようにする\n        - assert sum(5)== 5 → assert sum(5, []) == 5 → assert sum([5, 7]) == 12\n- 必要なオブジェクトを作る(Arrange)(4)\n    - 意図を伝えやすい生成方法を選ぶ(直接インスタンス生成するかメソッドを使うか)\n    - 処理が重い・準備に手間が掛かるリソースは決められた結果を返すモック作成(DBなど)\n        - 存在しない外側の機能を使って先に内側の機能を作る\n        - モックの書きにくさが設計の悪さを察知\n    - 稀な例外は特定の振る舞いのみが特別な専用クラス作成(Crush Test Dummy)(FullFileなど)\n    - テスト内の反復処理はパラメトライズ\n\t\n## Red(3)　　テストの失敗(不具合)\n\n### Redの方針(1)\n- Redは1つ以下にする・2つ以上の場合ロールバックして1つに減らす\n\n### Redの修正(2)\n- 書くべきことが分かる場合すぐに実装を書く(明白な実装)\n- 書くべきことがわからない場合や予期しないRedがある場合回帰テスト\n    1. Greenにするための最小限の変更(仮実装)　ex: テストする値をそのまま書く\n    2. 実装とテストの重複を除去　ex: 変数に置き換える\n\t\n## リファクタリング(8)　　テストが通り続ける変更\n\n### リファクタリングの方針(4)\n- 実装とテストの重複を除去(コードの内容を近づけていき一致したところで除去)\n    - テスト数を変えずコードのロジックをシンプルにしてカバレッジを上げる\n- 1度に変更するメソッドは1つのみ\n- 修正のための修正(割り込み)は1回まで\n- 新しい概念のメタファーを考えてリファクタリング?\n\n### テストコードのリファクタリング(2)\n- 重複するテストは自身と読み手への情報が減らない場合に消す\n- 複数のテストが使う共通のオブジェクトはフィクスチャ(setup・teardown)\n    - 異なるフィクスチャを使いたい場合はテストクラス分割　ex: Rectangle(0, 0)と(1, 1)\n\t\n### 実装コードのリファクタリング(2)\n- 何をしているかわからなくなった場合一旦メソッドをインライン化\n    - 処理を具体化してロジックをわかりやすくする\n        - bank.reduce(sum, “USD”) → sum.reduce(bank, “USD”)\n- 一般化の方法がわからない場合2つ目の実例をテスト(三角測量)\n\n## その他のTDD\n- ATDD(受け入れテスト駆動開発)\n    - エンドユーザが求める機能のTDDとそれを成功させるためのTDDの2ループを持つ開発手法\n- BDD(振る舞い駆動開発)\n    - ATDDの外側をエンドユーザと要件を確認してATDDを行う手法\n    - ステークホルダーの視点で振る舞いを説明することでアプリケーションを実装\n\t\n## カバレッジ\n- C0　 全命令を少なくとも1回実行しているか(ステートメントカバレッジ)\n    \n    a = 1\n    \n    ```Python\n    if (a > 0) {\n        print(\"a is positive\")\n    }\n    print(\"End of program\")\n    ```\n    \n- C1　 全条件分岐を少なくとも1回真と偽で実行しているか(ブランチカバレッジ)\n    \n    a = 1, -1\n    \n    ```Python\n    if (a > 0) {\n        print(\"a is positive\")\n    }\n    print(\"End of program\")\n    ```\n    \n- C2　 複合条件含む全条件を少なくとも1回真と偽で実行しているか(条件カバレッジ)\n    \n    (a, b) = (1, 1), (-1, 1), (1, -1), (-1, -1)\n    \n    ```Python\n    if (a > 0 and b > 0) {\n        print(\"a and b are positive\")\n    }\n    print(\"End of program\")\n    ```\n    \n- MD・DC　 複合条件含む全条件が独立して結果に影響を与えるか(修正条件・決定カバレッジ)\n    \n    (a, b, c) = (1, 0, 1), (0, 1, 1), (0, 0, 1), (1, 1, 0)\n    \n    a: (1, 0, 1), (0, 0, 1)\n    \n    b: (0, 1, 1), (0, 0, 1)\n    \n    c: (1, 0, 1), (1, 1, 0)\n    \n    ```Python\n    if ((a > 0 or b > 0)) and c > 0) {\n        print(\"condition met\")\n    }\n    print(\"End of program\")\n    ```\n    \n# Domain Driven Design(DDD)\n\n## DDD実装パターン(軽量DDD)\n- ドメインモデル　　小さな対象領域を独立したオブジェクトのモデルとして整理したモデル\n    - 機能からでなく関心事からドメインモデル作成\n        - 機能の一部として作らない(機能中心に設計して依存関係が生まれる)\n            - 年齢を知りたいという関心事 → 計算するロジックを置く場所として年齢クラス作成\n- ドメインオブジェクト　小さな対象領域のデータとプロセスをまとめたオブジェクト\n    - 非プリミティブ型を用いて必要な制約・関連メソッドのみを持つオブジェクトを設計\n    - Value Object　　値への制約と関連メソッドを持つオブジェクト(データの種類毎に作成)\n        - フィールドは不変(コンストラクタでフィールドを定義してsetterを作らない)\n        - プリミティブ型に制約を課す(int: -21億~21億の範囲・str: 無限長で形式自由・…)\n        - フィールドが全て等しい同型のValue Objectを同一とみなす\n    - Entity　　識別子が等しい同型のValue Objectを同一とみなす可変なValue Object\n    - Collection Object　　コレクションへの制約と関連メソッドを持つオブジェクト\n        - コレクションそのもののgetterは作らず内部のコレクションを閉じ込める\n        - getterを作る場合必要な要素を取り出すメソッドのみを作る\n        - setterを作る場合結果を同じ型の新しいCollection Objectで返す\n    - 区分オブジェクト　　列挙型を用いた区分毎のクラス・オブジェクトを持つオブジェクト\n        - 区分毎のクラス・オブジェクトをフィールドに持ちインターフェースのメソッドを持つ  \n            ```Python\n            class FeeType(Enum):\n                adult = AdultFee()\n                child = ChildFee()\n                senior = SeniorFee()\n            \n            \t\t@property\n                def yen(self) -> Yen:\n                    return self.value.yen()\n            \n                @property\n                def label(self) -> Label:\n                    return self.value.label()\n            \n            if __name__ == \"__main__\":\n            \t\tadultfee: FeeType = FeeType.adult\n            ```\n        - 状態遷移の制約を”遷移元”: set(”遷移先”, …)と表し遷移可能かどうかなどを判定可能\n        - インターフェースで同一視可能なクラス・オブジェクトを扱う場合は区分オブジェクト\n        - インターフェースで利用制限したオブジェクトをクラスに注入する場合はDI(依存性注入)\n\n## ドメインモデル分析設計(ドメインモデリング)\n- ソフトウェアの目的　　人間の役に立つこと　要件(人間のやりたいこと)を実現すること\n- 分析　　要件を理解して整理する(要件の聞き取り・不明点の確認・視覚化・文書化)\n- 設計　　要件をソフトウェアとして実現する方法を考える(パッケージ・クラス・メソッド)\n    - 部分を作りながら全体を組み立てる(ボトムアップ型)\n    - 重要な部分(間違いなく必要な部分)から作る\n    - 具体的な用語・概念の単位でドメインモデルを設計\n    - 例外含む要件の手順それぞれのビジネスルールを列挙してオブジェクト化\n        - ビジネスルール　　起きて良いこと・いけないことの判断と対応のルール\n            - 受注(発生源が外部のヒト)　ビジネスルール: 在庫はあるか・契約に違反しないか\n            - 在庫: 数量パッケージを考える　販売可能数量 -使う→ 数量 -持つ→ 数量単位\n            - 例外の判断材料　予定と実績の記録→差異の判別(予定・実績を用いた差異クラス)\n                - 業務の関心事のパターンp112−120, 125-129\n    - 不足しているドメインオブジェクトを見つけながらドメインモデルに追加していく\n    - 実際にコードを書いてみる → 業務知識を増やして洗練していく\n    - コードを変更する度に設計の改善を考える\n        - ビジネスロジックがドメインモデル以外に含まれていないか\n        - パッケージ図　　全体を俯瞰する図\n        - 業務フロー図　　業務活動を時間軸に沿って図示した図\n            - 活動の主体毎にレーンを並べて情報のやり取りを整理\n\n## ドメインモデルアーキテクチャ\nドメインモデル・プレゼンテーション層(画面)・アプリケーション層(アプリの手続き)・データソース層(DB)で分ける場合ビジネスロジックの記述はドメインモデルのみ\n\n### アプリケーション層(アプリの手続き/進行)　サービスクラス\n- ビジネスロジックが含まれていないかを考える　シンプルに保つ\n- 登録系と参照系に分ける　p160-164\n    - 契約による設計　　サービスを利用する側とサービスを提供する側とで約束ごとを決めて設計をシンプルに保つ設計\n        - Noneを返さない\n        - 状態に依存する場合使う側が事前に確認\n        - 契約を守った上で異常が起きた場合例外を通知\n            - Noneを返す場合があるメソッドの前に確認するプロセスを入れて通常だとNoneがでないようにしてそれでもNoneが出た場合は例外\n- 基本サービスを提供するサービスクラス群と基本サービスを組み合わせる複合サービスを提供するシナリオクラス群作成\n- データベース操作を業務の関心事として捉える\n    - リポジトリ　　ドメインオブジェクトの保管と取り出しが可能な架空の収納場所\n        - 全てのドメインオブジェクトを保管していつでも取り出せる仕組み\n        - メソッド名・パラメータ・戻り値は全て業務の用語で表現\n        - サービスクラスにデータベース操作の詳細を意識させない\n        - インターフェース宣言してデータソース層のクラスで実装\n- リポジトリを用いた業務データの記録と参照はデータベース操作ではなく業務の関心事として記述するための工夫\n\n### データソース層(DB)\n- 適切なデータベース設計をする\n    - 命名・データ型・制約(NOT NULL制約/一意性制約/外部キー制約)\n- 列は全てNOT NULL制約\n    - NULLがどうしても必要なカラムは別テーブルに分けることを検討\n- 記録のタイミングが異なるデータはテーブルを分ける(NULLをなくす)\n- 列の追加はテーブルを追加する\n- データベース　　事実の記録\n    - 記録は変更(UPDATE)を禁止\n        - 取り消しを記録し変更を別の記録として追加(不整合を防ぐ)\n    - 記録の度に状態を更新するテーブルを用意(DELETE → INSERTで状態を更新)\n    - 非同期メッセージング　　記録と更新などの非同期な処理を分散して簡単に処理する方法\n    - イベントソーシング　　事実の記録を基本にして派生する情報を目的別に記録する方式\n        - 厳密な即時性はない\n\n### プレゼンテーション層(画面)\n- 内部の処理は関心事に応じて小さく分ける(タスクベース)\n    - タスクベースのユーザーインターフェース　　用途を特定した小さな単位に分けた画面\n- 画面の表示にはドメインオブジェクト(タスクベース)かビューオブジェクト(何でも画面)を用いる\n    - メインオブジェクトは論理的ビューを持つ(ex: 数字のカンマや千円単位の表示)\n    - 論理的ビュー(段落数, 最も長い段落の文字数のカウント, 最初の段落の20文字だけ表示する…)\n    - 物理的ビュー(ex: <p>で囲む, 段落の先頭を全角1文字で字下げする…)\n        - 文字列の配列で段落表現\n- 場合ごとの表示の違いをドメインオブジェクトで出し分ける\n    - {}件見つかった・見つからなかった\n    - モデルがビューの関心事を持つのではなくモデルで表現できる論理的な状態をビューが利用\n- ドメインオブジェクトも画面も利用者の関心事に焦点を当てるため同一視\n    - 画面の表示と一致したドメインオブジェクト作成\n        - history_idを抜いて表示順にしたHistory)\n    - 変換の複雑さを持ち込むのはドメインオブジェクトに他アプリ形式への依存を作らないため\n        - Web APIのjsonデータの格納でも同様\n        - 画面のデザインとドメインオブジェクトの対応p220-224\n- 例外処理を記述\n\n# Clean Architecture\n\n## ソフトウェアアーキテクチャ　　ソフトウェアの性質を決定する設計方法\n- プログラムの構成要素をどのように組み立てるかのルールは全て同じ\n- 目的　　求められるシステムを構築・保守するための人材の最小化\n\n## アーキテクチャの目的　　保守性・拡張性を高める\n- OO駆動型などを使うのは動作させるためじゃない\n- 優れたアーキテクトは決定しない数を最小化する\n- DBやWebサーバなどの決定を遅延して抽象的にし依存性を低くする\n- 方針と詳細を切り離す\n \n### SOLID原則\nモジュールレベルでの保守性・拡張性向上のための考え方\n- 単一責任の原則(SRP: Single Responsibility Principle)　　モジュールが単一の役割を持つ\n    - 役割の異なるモジュールは分割(Facade)\n        ```Rust\n        // 違反例\n        struct Employee;\n        \n        impl Employee {\n        \t\tfn calculate_pay() -> i32 {} // 経理 -> CFO\n        \t\tfn report_hours() -> i32 {} // 人事 -> COO\n        }\n        ```\n        ```Rust\n        // 改善例\n        struct EmployeeData;\n        \n        trait PayCalculator { // 経理 -> CFO\n        \t\tfn calculate_pay() -> i32;\n        }\n        \n        trait HourReporter { // 人事 -> COO\n        \t\tfn report_hours() -> i32;\n        }\n        \n        struct Employee {\n        \t\tdata: EmployeeData\n        };\n        \n        impl PayCalculator for Employee {\n        \t\tfn calculate_pay() -> i32 {}\n        }\n        \n        impl HourReporter for Employee {\n        \t\tfn report_hours() -> i32 {}\n        }\n        ```\n- 開放閉鎖の原則(OCP: Open-Closed Principle)　　モジュールを変更せず拡張可能\n    - 変更の影響を受けないようにコンポーネントをレベル階層に分ける\n        - 高レベルコンポーネントは低レベルコンポーネントの実装を知らない\n            - コンポーネント間をインターフェース経由にする\n- リスコフの置換原則(LSP: Liskov Substitution Principle)　　上位型を部分型に置換可能\n    - 上位型の全性質を部分型が持っている必要がある\n- インターフェース分離の原則(ISP: Interface Segregation Principle)\n    - 上位型が持つ, 部分型が利用しないメソッドと部分型を分離\n    - 役割毎のインターフェースで各メソッドの依存関係をなくす\n- 依存関係逆転の原則(DIP: Dependency Inversion Principle)\n    - 部分型が上位具象型ではなくインターフェースに依存(標準機能など不変とみなせる型を除く)\n        - 変化しやすい具象型を参照しない\n            - 生成する場合具象型を参照するため生成専用クラス作成(Abstruct Factory)\n        - 抽象コンポーネントと具象コンポーネントを分けると依存性と処理の流れは逆向きになる\n            - インターフェースは依存関係を逆転\n\nコンポーネントレベルでの考え方\n- コンポーネント　　デプロイできる最小単位\n    - コンパイラ言語はバイナリファイル・インタープリタ言語はソースファイル\n- CCP・REP・CRPのバランスを取る必要がある\n\n### 閉鎖性共通の原則(CCP)\n- 変更の理由やタイミングが同じクラスをコンポーネントにまとめる・異なるクラスを分ける\n    - コンポーネントを変更する理由が複数あってはならない(一般化SRP)\n\n### 全再利用の原則(CRP)\n- コンポーネントのモジュールに利用しないモジュールへの依存を強要しない\n    - 密結合していないモジュールをコンポーネントにまとめてはならない\n\n### 再利用・リリース等価の原則(REP)\n- 再利用の単位とリリースの単位は等価\n    - コンポーネント形成モジュールは凝集性がありまとめてリリース可能にする必要がある\n\n### 非循環依存関係の原則(ADP)\n- コンポーネントの依存関係に循環があってはいけない\n    - インターフェースを用いて依存関係逆転(IDP)\n- 循環依存がないと下位コンポーネントからボトムアップに実装できる\n\n### 安定依存の原則(SDP)\n- 安定度の高い方向に依存するようにする(変化しやすいモジュールに依存しない)\n    - 多数コンポーネントから依存されるコンポーネントは変更しづらく安定\n    - 独立コンポーネント　　多数コンポーネントから依存され他コンポーネントに依存しない(外部要因で変更が必要にならない)変更しにくい安定なコンポーネント\n    - 従属コンポーネント　　他コンポーネントに依存されず多数コンポーネントに依存する変更しやすい不安定なコンポーネント\n    - (安定度) = (依存入力数) / (依存入力数 + 依存出力数) [0, 1]\n        - コンポーネント図は安定度が大きいほうが下\n    - (上位コンポーネントの安定度) < (下位コンポーネントの安定度)\n\n### 安定度・抽象度等価の原則(SAP)\n- コンポーネントの抽象度は安定度と同程度でなければならない\n    - (+SDP)抽象度の高い方向に依存するようにする(IDP)\n    - (抽象度) = (インターフェース数) / (クラス数) [0, 1]\n        - 抽象度と安定度の差が小さいほどよい\n    - 下位コンポーネントにインターフェースを実装\n\n# Refactoring\n外部の振る舞いを変更せず内部の実装を変更すること\n- 修正や機能の追加を速める(経済的効果がある)\n\n## 手順\n1. テストを書く\n2. 作業を小さく分割してリファクタリング\n3. リファクタリングが成功する度にcommit\n\n## リファクタリングタイミング(15)\n- 不正確な名前\n- 重複したコード\n- パラメータ数が多い関数\n- グローバルなオブジェクト(グローバル変数・クラス変数・Singleton)\n- 同形式の制御構文\n- (パイプラインが最適な言語における)反復処理\n- 複数の責務・分散した責務を持つ・責務のない変数, 関数, クラス, モジュール\n- 高凝集低結合でないクラス・モジュール\n- 上位型のメソッドが必要ない継承\n- プリミティブ型の濫用\n- 同じクラスでないオブジェクト群\n- mutableオブジェクト\n- getter・setter以外にメソッドを持たないデータクラス\n- 関数に見えるオブジェクトのメソッドが返すオブジェクトへの操作を行う関数(稀に必要)\n- 不吉な臭いを隠すコメント\n\n## リファクタリングの原則(4)\n- 機能の追加とリファクタリングを区別\n- リファクタリングによるトレードオフを意識\n- パフォーマンスを意識する場合まずチューニングしやすく作り段階的に速くする\n- 外部の振る舞いを変更しないカプセル化が重要\n\n## リファクタリングの規則(30)\n\n### コード(5)\n- 命名の変更\n- 文のスライド　　責務の可視化・変数の寿命短縮\n- 処理の置換・削除　　処理の最適化　ex: setterの除去\n- 責務(変数・反復)の分離　　責務の区別(責務毎に段落で分離・共通の変数名を責務毎に変更)\n- アサーションの導入　　常に満たすべき条件の明示\n\n### クラス(15)\n- 変数のカプセル化　　変数の可視性の制限(関数経由の変数参照)\n- プリミティブのカプセル化　　　データと関数間の関係の明示・操作の制限\n- 参照から値への変更　フィールドのimmutable化(オブジェクトの状態変更でなく新規作成)\n- 値から参照への変更　　データの更新(リポジトリによりコピーを作る必要がない)\n- クラスの抽出　　単一責務化・高凝集化\n- クラスのインライン化　　責務のないクラスの除去/処理の具体化\n    - 上手く分割できていないクラス群を再分割\n- フィールドの移動　　データ間の関係の明示\n- ローカル変数のフィールド化　　重複処理の除去\n- 委譲の隠蔽　　委譲先以外への依存関係の除去(アクセスしたクラスのメソッドにメソッドを移動)\n- メソッド・フィールドの引き上げ　　重複の除去(ex: コンストラクタの引き上げ)\n- メソッド・フィールドの押し下げ　　不要な処理の除去\n- スーパークラスの抽出　　重複処理の除去\n- サブクラスの削除　　重複処理の除去(クラスの抽出より先に考慮して変更する場合委譲)\n- 委譲によるサブクラスの置換　　クラス間の低結合化・クラス階層の最適化\n- 委譲によるスーパークラスの置換　　クラス間の低結合化・クラス階層の最適化\n\n### 関数(10)\n- パラメータの変更　　責務の境界線の決定(ex: 値のみを持つかobjそのものを持つか)\n- パラメータクラスの作成　　データ間の関係の明示/パラメータ数の最小化(ex: Value Object)\n- フラグパラメータの除去　　単一責務化\n- 関数の移動　重複処理の除去(関数内関数の移動)・データと関数間の関係の明示(メソッド化)\n- 変数の抽出　　処理への命名(スコープ内のみで意味を持つ場合)\n- 関数の抽出　　単一責務化・処理への命名(スコープ外でも意味を持つ場合)\n- 変数・関数のインライン化　　処理の具体化(上手く分割できていない関数群を再分割)\n- 一時変数の関数化　　副作用の除去(変更可能な場合)・重複処理の除去\n- 定数のパラメータ化　　重複処理の除去\n- コマンドとクエリの分離　　副作用の分離\n- 条件の統合\n- ガード節による条件の置換・逆転　　正常な条件分岐と例外処理の区別\n- ポリモーフィズムによる条件分岐の置換　複雑な条件分岐の除去(上位型とファクトリ関数)\n- ポリモーフィズムによる例外ケースの置換　　例外動作の重複除去(Null Objectパターン)\n- ファクトリ関数によるコンストラクタの置換　　処理への命名・パラメータの多様化\n\n# Programming Paradigm\n\n## Object Oriented Programming(OOP)　　カプセル化とポリモーフィズムを用いる考え方\n- カプセル化　　クラスを用いてデータとデータに関連するプロセスを閉じ込めて外部からの直接アクセスを制限\n    - クラス　　フィールド(データ)とメソッド(プロセス)を合わせて定義するオブジェクトの型\n    - オブジェクト　　クラスを実体化(インスタンス)したもの\n- ポリモーフィズム(多態性)　　クラスの関係性を作り異なるクラスのオブジェクトに同じメソッドを持たせること\n- 部分型　　他のクラス(上位型)を基底として作るクラス　関係性を作る\n    - 集約　　上位型が外部オブジェクトをフィールドに持つこと(has-a)\n        - 他のオブジェクトでも使われる部品\n    - 合成　　上位型が部分型オブジェクトを生成してフィールドに持つこと\n        - そのオブジェクトでしか使われない部品\n        - 部分型が上位型の変更の影響を受けにくい(疎結合)\n        - 委譲　　上位型が内部で部分型のメソッドを実行すること\n- インターフェース　部分型に同じ形式(名前・引数/戻り値の型)のメソッドを持たせる上位型\n    - インターフェースは実装の詳細を持たない\n    - インターフェースは抽象度の高い処理に対して抽象度の低い実装の影響を分離(疎結合)\n    - インターフェースはフィールドに持つオブジェクトのメソッドを制限\n    - プロトコル　　同じメンバを持つ型を部分型として扱うインターフェース(構造的部分型)\n        - クラス間の物理的依存関係を作らない(疎結合)/フィールドの形式も指定可能\n        - 複合プロトコル　　複数のプロトコルを多重継承したプロトコル\n            - 物理的依存関係がないためプロトコルの多重継承は安全\n    - 抽象クラス　　抽象メソッドのみを持つことが保証されるインターフェース(≒Mixin)\n        - 抽象メソッド　　継承により部分型に実装を強制するメソッド\n- 継承　　上位型の全メンバをコピーして部分型を作ること(is-a)　基本非推奨\n    - ユースケース\n        - たった1つのカテゴリのみ異なる振る舞いを持つオブジェクト\n        - 上位型の代わりに部分型が使えるかつどちらも使用する関係を明確にする場合\n        - 親クラスの全メソッドが子クラスにおいて意味を持つ場合(リスコフの置換原則)\n        - 子クラスの全インスタンスが親クラスのインスタンスとして使用する全ての場合で有効な場合\n        - 親クラスが子クラスの情報を持たない場合\n    - 多重継承　　多種類の上位型の継承　複雑性により非推奨\n    - Mixin　　メソッドのみを持つクラスの(多重)継承(**≒抽象クラス)**\n        - フィールドの有無(クラスかMixinか)を区別できない\n- 手続き型とオブジェクト指向はトレードオフ\n    - 手続き型　　既存のデータクラスを変更せず関数を追加可能\n    - オブジェクト指向　　既存の関数を変更せずクラスを追加可能\n- オブジェクトとデータ構造(DTO: データ転送クラス)\n    - オブジェクトはカプセル化を用いてデータを隠蔽しメソッドを通じてのみデータにアクセスを許可\n    - データ構造はデータを公開し外部から直接操作を許可\n    - データを外部から直接操作可能な、メソッドを持つオブジェクトとデータ構造の混血児を作らない\n    - オブジェクトはカプセル化するべきでデータ構造はビジネスロジックをもつべきでないという話\n- AOP(アスペクト指向プログラミング) = デコレータ\n    - クラス間を横断する機能(ログ出力や認証)などのオブジェクト指向では分離できない横断的関心事に対して、別個分離して記述することで重複を防ぐ試み\n\n## Functional Programming(FP)\n以下の特性を持つ式や関数を用いる考え方\n- 変数不変性　　変数の値を変更不可能\n    - =演算子が数学的な等価を表す(≠代入)\n    - 状態ではなく履歴からの計算を随時行えば可変変数は必要ない(イベントソーシング)\n- 参照透過性　　式や関数の構成要素が同じ場合常に同じ値・状態になること\n    - 副作用(関数内で戻り値以外の状態を変更する箇所)をなくす・影響範囲を狭める\n    - 純粋関数　　参照透過な関数(数学的な意味の関数)　並列処理やテストが容易\n- 関数のオブジェクト化　　関数をオブジェクトとして扱う\n    - 関数を引数として処理を変化させるデコレータ(高階関数・コールバック関数)\n    - 外側の関数の引数によって処理を変化させるクロージャ\n- 遅延評価　　演算の実行直前に必要な値の処理を実行すること\n    - 条件分岐などで演算をしない場合必要な値の処理をしないため効率的\n\n# Software Architecture\n\n## Onion Aichitecture\n\n# Software Design\n\n## Design Principle\n\n### DRY原則(Don’t Repeat Yourself)\n- 重複部分を抽象化して排除\n### YAGNI原則(You aren’t going to need it)\n- 今必要な機能のみ実装\n### F.I.R.S.T\n\nクリーンテストの条件\n- Fast(高速)\n- Independent(独立)　　テストの成否が他のテストの結果に影響しない　好きな順序で実行可能\n- Repeatable(再現可能)　　どんな環境でも再現可能\n- Self-Validating(自己検証可能)　　テストは成功か失敗のどちらかのみを出力\n- Timely(適時性)　　テストは必要な場合すぐ書けなければならない\n\n### ケント・ベックの単純な設計のための4つの規則\n- 全テストを実行\n- 重複がない\n- プログラマの意図が表現\n- クラスとメソッドの数を最小化　最も優先度が低い\n\n### デメテルの法則(たまに役立つデメテルの提案)\n\n関数は、関数から見えているオブジェクトのメソッドのみを使用するべきであり、\nそのオブジェクトのメソッドが返すオブジェクトの内部について知るべきではない ≠ データクラス\nクラスCのメソッドfについて、fは次のオブジェクトのメソッドのみを呼び出すべきである\n- Cのメソッド\n- Cのインスタンス変数オブジェクトのメソッド\n- fの引数オブジェクトのメソッド\n- fで生成されたオブジェクトのメソッド\n    - x final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()\n\n### ボーイスカウトの規則\n- 読んだコードを読む前よりもきれいにすること\n\n### ブルックスの法則\n- 遅延プロジェクトに人員を投入しても更に遅らせるだけ\n\n### マーフィーの法則\n- プロジェクトは所要時間を使い切るまで肥大化\n\n### コンウェイの法則\n- システムを設計する組織は組織のコミュニケーション構造と同一の構造の設計を生み出す\n\n## Design Pattern\n### 生成(4)\n- Builder　　生成オブジェクトに具体的な性質を付与するメソッドをもつクラスのインターフェース　objの構成要素の拡張　ラップ\n\t- DirectorがBuilderのメソッドを操作しオブジェクトに性質を付与する　カプセル化\n\t- 新しい、オブジェクトの構成プロセスを簡単に追加可能　疎結合\n    \n    ```Python\n    # Builder\n    class SandwichBuilder(Protocol):\n    \t\tsandwich: Sandwich\n    \n    \t\tdef add_bread(self) -> None:\n    \t\t\t\tpass\n    \n    \t\tdef add_fillings(self) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Builder\n    class VeggieSandwichBuilder:\n    \t\tdef __init__(self) -> None:\n    \t\t\t\tself.sandwich = Sandwich()\n    \n    \t\tdef add_bread(self) -> None:\n    \t\t\t\tself.sandwich.bread = \"grain bread\"\n    \n    \t\tdef add_filling(self) -> None:\n    \t\t\t\tself.sandwich.fillings = \"Tomato\"\n    \n    \n    class ChickenSandwichBuilder:\n    \t\tdef __init__(self):\n    \t\t\t\tself.sandwich = Sandwich()\n    \n    \t\tdef add_bread(self) -> None:\n    \t\t\t\tself.sandwich.bread = \"White bread\"\n    \n    \t\tdef add_fillings(self) -> None:\n    \t\t\t\tself.sandwich.fillings = \"Grilled chicken\"\n    \n    \n    # Director: Builderを使用してオブジェクトを構築\n    class SandwichDirector(BaseModel):\n    \t\tbuilder: Builder\n    \n    \t\tdef make_sandwich(self) -> Sandwich:\n    \t\t\t\tself.builder.add_bread()\n    \t\t\t\tself.builder.add_fillings()\n    \t\t\t\treturn self.builder.sandwich\n    \n    \n    # Product\n    class Sandwich:\n    \t\tdef __init__(self) -> None:\n    \t\t\t\tself.bread = None\n    \t\t\t\tself.fillings = None\n    \t\t\t\t\n    ```\n- Factory Method　　インターフェースによる、具体的なクラスを指定しないオブジェクト生成メソッド　objの種類の拡張\n\t- 新しい種類のクラスを簡単に追加可能　疎結合\n    ```Python\n    # Product\n    class Animal(Protocol):\n    \t\tdef speak(self) -> str:\n    \t\t\t\t...\n    \n    \n    # Concrete Product\n    class Dog:\n    \t\tdef speak(self) -> str:\n    \t\t\t\treturn \"Woof!\"\n    \n    \n    class Cat:\n    \t\tdef speak(self) -> str:\n    \t\t\t\treturn \"Meow!\"\n    \n    \n    \\#Creator: Factory Methodをもつ(インスタンス化させる具体的なクラスは知らない)\n    class AnimalFactory(Protocol):\n    \t\tdef create_animal(self) -> Animal:\n    \t\t\t\t...\n    \n    \n    \\#Concrete Creator: 具体的なFactory Methodをもつ\n    class DogFactory:\n    \t\tdef create_animal(self) -> Animal:\n    \t\t\t\treturn Dog()\n    \n    \n    class CatFactory:\n    \t\tdef create_animal(self) -> Animal:\n    \t\t\t\treturn Cat()\n    ```\n- Abstract Factory　　ある特性をもつオブジェクト群の生成メソッドをもつクラスのインターフェース　objの関連性の拡張\n\t- Factoryが関連するオブジェクトの一括生成による高い結合性を実現\n\t- オブジェクト群の新しい関連性を簡単に追加可能　疎結合\n    ```Python\n    # Abstract Product\n    class Button(Protocol):\n    \t\tdef click(self) -> str:\n    \t\t\t\t...\n    \n    \n    class  CheckBox(Protocol):\n    \t\tdef check(self) -> str:\n    \t\t\t\t...\n    \n    \n    # Concrete Product\n    class DarkButton:\n    \t\tdef click(self) -> str:\n    \t\t\t\treturn \"Dark button clicked!\"\n    \n    \n    class LightButton:\n    \t\tdef click(self) -> str:\n    \t\t\t\treturn \"Light button clicked!\"\n    \n    \n    \n    class DarkCheckBox:\n    \t\tdef check(self) -> str:\n    \t\t\t\treturn \"Dark checkbox checked!\"\n    \n    \n    class LightCheckBox:\n    \t\tdef check(self) -> str:\n    \t\t\t\treturn \"Dark checkbox checked!\"\n    \n    \n    # Abstract Factory\n    class GUIFactory(Protocol):\n    \t\tdef create_button(self) -> Button:\n    \t\t\t\t...\n    \n    \t\tdef create_checkbox(self) -> CheckBox:\n    \t\t\t\t...\n    \n    \n    \\#Concrete Factory\n    class DarkThemeFactory:\n    \t\tdef create_button(self) -> Button:\n    \t\t\t\treturn DarkButton()\n    \n    \t\tdef create_checkbox(self) -> CheckBox:\n    \t\t\t\treturn DarkCheckBox()\n    \n    \n    class LightThemeFactory:\n    \t\tdef create_button(self) -> Button:\n    \t\t\t\treturn LightButton()\n    \n    \t\tdef create_checkbox(self) -> CheckBox:\n    \t\t\t\treturn LightCheckBox()\n    ```\n- Singleton　　生成するインスタンスが全て同一なクラス　カプセル化されたグローバルなデータ　非推奨\n\t- 全体で共有したいデータの管理　カプセル化\n\t- グローバル変数の問題を引き起こす\n    ```Python\n    class Singleton:\n        _instance = None\n    \n        def __new__(cls):\n            if cls._instance is None:\n                cls._instance = super().__new__(cls) \\#instanceをフィールドに保存\n                # 他の初期化処理\n            return cls._instance\n    ```\n### 構造(6)\n- Adapter　　既存オブジェクトであるメンバのメソッドを新しいメソッドで呼び出すことで別のインターフェースに変換するクラス　既存クラスの再利用\n\t- 既存のクラスを変更せず新しいインターフェースで再利用可能　Wrapper\n    ```Python\n    # Target\n    class ThreePinSocket(Protocol):\n    \t\tdef connect_three_pin(self) -> str:\n    \t\t\t\t...\n    \n    \n    # Adaptee\n    class TwoPinPlug:\n    \t\tdef connect_two_pin(self) -> str:\n    \t\t\t\treturn \"2ピンのプラグを接続しました。\"\n    \n    \n    # Adapter\n    class TwoToThreePinAdapter(BaseModel):\n    \t\tplug: TwoPinPlug\n    \n    \t\tdef connect_three_pin(self) -> str:\n    \t\t\t\treturn self.plug.connect_two_pin() + \"３ピンのソケットにアダプタを使用して接続しました。\"\n    ```\n- Facade　　合成により複数クラスを管理する単純なクラス　複数クラスのメソッドの統合\n\t- 複数のクラスを単純なクラスで操作可能(ファサード)\n    ```Python\n    # Subsystem\n    class Amlifier:\n    \t\tdef on(self) -> None:\n    \t\t\t\tprint(\"Amplefier is on\")\n    \n    \t\tdef set_volume(self, level: int) -> None:\n    \t\t\t\tprint(f\"Setting volume to {level}\")\n    \n    \n    class Tuner:\n    \t\tdef set_am(self) -> None:\n    \t\t\t\tprint(\"Setting to AM mode\")\n    \n    \t\tdef set_fm(self) -> None:\n    \t\t\t\tprint(\"Setting to FM mode\")\n    \n    \n    class CDPlayer:\n    \t\tdef play(self, track: int) -> None:\n    \t\t\t\tprint(f\"Playing track {track}\")\n    \n    \n    # Facade\n    class MusicSystemFacade(BaseModel):\n    \t\tamp: Amlifier\n    \t\ttuner: Tuner\n    \t\tcd_player: CDPlayer\n    \n    \t\tdef play_music(self, track: int) -> None:\n    \t\t\t\tself.amp.on()\n    \t\t\t\tself.amp.set_volume(5)\n    \t\t\t\tself.tuner.set_fm()\n    \t\t\t\tself.cd_player.play(track)\n    ```\n- Proxy　　他のオブジェクトへの操作を制御するための代理オブジェクト　objへの操作の制限や追加機能\n\t- オブジェクトへの制御や追加機能を簡単に行える\n    ```Python\n    # Subject\n    class Database(Protocol):\n    \t\tdef request(self) -> None:\n    \t\t\t\tpass\n    \n    \n    # Real Subject\n    class RealDatabase:\n    \t\tdef request(self) -> None:\n    \t\t\t\tprint(\"RealDatabase: Handling the request.\")\n    \n    \n    # Proxy\n    class DatabaseProxy(BaseModel):\n    \t\t_database: Database = PrivateAttr()\n    \n    \t\tdef request(self) -> None:\n    \t\t\t\tif not self._database:\n    \t\t\t\t\t\tself._database = RealDatabase()\n    \t\t\t\tprint(\"Proxy: Forwarding the request to RealDatabase.\")\n    \t\t\t\tself._database.request()\n    ```\n- Imposter　　複数のオブジェクトをまとめそれらのような振る舞いをするオブジェクト(抽象化)\n    - Composite　　個別のオブジェクトとコンテナオブジェクト両方に共通のインターフェース　objと一貫性のあるcontainerの種類の拡張\n\t    - オブジェクトと一貫性のあるcontainerを簡単に追加可能\n        ```Python\n        # Component\n        class FileComponent(Protocol):\n        \t\tname: str\n        \n        \t\tdef show(self) -> None:\n        \t\t\t\tpass\n        \n        \n        # Leaf\n        class FileLeaf(BaseModel):\n        \t\tname: str\n        \n        \t\tdef show(self) -> None:\n        \t\t\t\tprint(f\"File: {self.name}\")\n        \n        \n        # Composite\n        class DirectoryComposite(BaseModel):\n        \t\tname: str\n        \t\t_children: list = PrivateAttr(default=[])\n        \n        \t\tdef add(self, component) -> None:\n        \t\t\t\tself._children.append(component)\n        \n        \t\tdef show(self) -> None:\n        \t\t\t\tprint(f\"Directory: {self.name}\")\n        \t\t\t\tfor child in self.children:\n        \t\t\t\t\t\tchild.show()\n        ```\n- Bridge　　機能と実装を分離するため、実装クラスをメンバにもつ機能クラス　機能と実装の拡張性　?\n\t- 機能と実装の分離により簡単に新しい機能、新しい実装を追加可能\n    ```Python\n    # Abstraction(Bridge): 機能の最上位クラス\n    class Device(BaseModel):\n    \t\timplementor: DeviceImplementor\n    \n    \t\tdef turn_on(self) -> None:\n    \t\t\t\t# 起動の準備　機能\n    \t\t\t\tself.implementor.turn_on()\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\t# 停止の準備　機能\n    \t\t\t\tself.implementor.turn_off()\n    \n    \n    # Refined Abstraction\n    class CleanDevice(BaseModel):\n    \t\t\n    \n    \n    # Implementor: 実装の最上位クラス\n    class DeviceImplementor(Protocol):\n    \t\tdef turn_on(self) -> None:　 # 起動　実装\n    \t\t\t\tpass\n    \n    \t\tdef turn_off(self) -> None:　# 停止　実装\n    \t\t\t\tpass\n    \n    \n    # Concrete Implementor\n    class RadioImplementor:\n    \t\tdef turn_on(self) -> None:\n    \t\t\t\tprint(\"Turn on radio.\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tprint(\"Turn off radio.\")\n    \n    \n    class TBImplementor:\n    \t\tdef turn_on(self) -> None:\n    \t\t\t\tprint(\"Turn on TV.\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tprint(\"Turn off TV.\")\n    ```    \n- Flyweight　　データ構造への参照で新規オブジェクトのかわりに返されるキャッシュオブジェクト　キャッシュによるメモリ節約\n\t- キャッシュによるメモリ節約\n    ```Python\n    # Flyweight\n    class Character(BaseModel):\n    \t\tchar: str\n    \n    \t\tdef display(self, font: str, size: int) -> None:\n    \t\t\t\tprint(f\"Displaying {self.char} in {font} with size {size}\")\n    \n    \n    # FlyweightFactory\n    class CharacterFactory(BaseModel):\n    \t\t_characters: dict = PrivateAttr(default={})\n    \n    \t\tdef get_character(self, char: str) -> dict[str, Character]:\n    \t\t\t\tif char not in self._characters:\n    \t\t\t\t\t\tself._characters[char] = Character(char)\n    \t\t\t\treturn self._characters[char]\n    ```\n### 振る舞い(8)\n- Command　　「1つの処理を表すクラス」のインターフェース　処理の実行のための処理を分離\n\t- 処理の実行のための処理(ex: 処理の記録や遅延処理)と実行を分離\n    ```Python\n    class Command(Protocol):\n    \t\tdef excute(self) -> None:\n    \t\t\t\tpass\n    \n    \n    class LightOnCommand(BaseModel):\n    \t\tlight: Light\n    \n    \t\tdef excute(self) -> None: # 処理の実行のための処理\n    \t\t\t\t...\n    \t\t\t\tself.light.turn_on()\n    \n    \n    class LightOffCommand(Basemodel):\n    \t\tlight: Light\n    \n    \t\tdef excute(self) -> None:\n    \t\t\t\t...\n    \t\t\t\tself.light.turn_off()\n    \n    \n    class Light:\n    \t\tdef turn_on(self) -> None: # 処理の実行\n    \t\t\t\tprint(\"Light is on\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tprint(\"Light is off\")\n    ```\n- Strategy　　アルゴリズムをカプセル化したクラスのインターフェース　実行時のアルゴリズム選択\n\t- アルゴリズムを簡単に追加/選択可能    \n    ```Python\n    # Strategy\n    class SortStrategy(Protocol):\n    \t\tdef sort(self, dataset: list) -> list:\n    \t\t\t\t...\n    \n    \n    # Concrete Starategies\n    class Bubblesort:\n    \t\tdef sort(self, dataset: list) -> list:\n    \t\t\t\tfor i in range(num_dataset := len(dataset)):\n    \t\t\t\t\t\tfor j in range(num_dataset-i-1):\n    \t\t\t\t\t\t\t\tif dataset[j] > dataset[j+1]:\n    \t\t\t\t\t\t\t\t\t\tdataset[j], dataset[j+1] = dataset[j+1], dataset[j]\n    \t\t\t\treturn dataset\n    \n    \n    class QuickSort:\n    \t\tdef sort(self, dataset: list) -> list:\n    \t\t\t\tnum_dataset = len(dataset)\n    \t\t\t\tif num_dataset <= 1:\n    \t\t\t\t\t\treturn dataset\n    \t\t\t\tpivot = dataset[len(dataset) // 2]\n    \t\t\t\tleft = [x for x in dataset  if x < pivot]\n    \t\t\t\tmiddle = [x for x in dataset if x == pivot]\n    \t\t\t\tright = [x for x in dataset if x > pivot]\n    \t\t\t\treturn self.sort(left) + middle + self.sort(right)\n    \n    \n    # Context\n    class SortContext(BaseModel):\n    \t\tstrategy: SortStrategy\n    \n    \t\tdef excute_sort(self, dataset: list) -> list:\n    \t\t\t\treturn self.strategy.sort(dataset)\n    ```\n- Mediator　　通信を行うオブジェクトの操作を行うクラスのインターフェース　通信の拡張　?\n\t- 通信を行うオブジェクトの管理を集中することで通信を簡単に拡張可能\n    ```Python\n    # Mediator: 仲介者\n    class Mediator(Protocol):\n    \t\tdef notify(self, sender: Room, event: str) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Mediator\n    class LightMediator(BaseModel):\n    \t\t_rooms: dict = PrivateAttr(default={})\n    \n    \t\tdef add_room(self, room: Room) -> None:\n    \t\t\t\tself.rooms[room.name] = room\n    \n    \t\tdef notify(self, sender: Room, event: str) -> None:\n    \t\t\t\tif event == \"ON\":\n    \t\t\t\t\t\tfor room_name, room in self.rooms.items():\n    \t\t\t\t\t\t\t\tif room_name != sender.name:\n    \t\t\t\t\t\t\t\t\t\troom.turn_off()\n    \n    \n    # Colleague\n    class Room(BaseModel):\n    \t\tname: str\n    \t\tmediator: Mediator\n    \t\tlight: str = \"OFF\"\n    \n    \t\tdef turn_on(self) -> None:\n    \t\t\t\tself.light = \"ON\"\n    \t\t\t\tself.mediator.notify(self, \"ON\")\n    \t\t\t\tprint(f\"{self.name} light is ON\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tself.light = \"OFF\"\n    \t\t\t\tprint(f\"{self.name} light is OFF\")\n    ```\n- Observer　　あるオブジェクトの状態変化を通知するクラスのインターフェース　通知の種類の拡張　?　処理フローがおいにくい\n\t- 状態変化により変化する通知オブジェクトの操作クラスを分離することで通知を新しく追加可能\n    ```Python\n    # Subject\n    class NewsService(BaseModel):\n    \t\t_observers: list = PrivateAttr(default=[])\n    \t\t_news: str | None = PrivateAttr(default=None)\n    \n    \t\tdef add_observer(self, observer: Subscriber) -> None:\n    \t\t\t\tself._observers.append(observer)\n    \n    \t\tdef remove_observer(self, observer: Subscriber) -> None:\n    \t\t\t\tself._observers.remove(observer)\n    \n    \t\tdef notify_observers(self) -> None:\n    \t\t\t\tfor observer in self._observers:\n    \t\t\t\t\t\tobserver.update(self._news)\n    \n    \t\tdef add_news(self, news: str) -> None:\n    \t\t\t\tself._news = news\n    \t\t\t\tself.notiry_observers()\n    \n    \n    # Observer\n    class Subscriber(Protocol):\n    \t\tdef update(self, news: str) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Observer\n    class EmailSubscriber:\n    \t\tdef update(self, news: str) -> None\n    \t\t\t\tprint(f\"Email: New news published - {news}\")\n    \n    \n    class SmsSubscriber:\n    \t\tdef update(self, news: str) -> None:\n    \t\t\t\tprint(f\"SNS: New news published - {news}\")\n    ```\n- State　　オブジェクトの内部状態を変更するクラスのインターフェース　内部状態に応じて動作を変更　?\n\t- 状態遷移のロジックを明確にして状態変更の種類を簡単に追加可能　\n    ```Python\n    # 　State\n    class TrafficLightState(Protocol):\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete State\n    class RedLight:\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tprint(\"Red Light -> Changing to Green\")\n    \t\t\t\tlight.state = GreenLight()\n    \n    \n    class GreenLight:\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tprint(\"Green Light -> Changing to Yellow\")\n    \t\t\t\tlight.state = YellowLight()\n    \n    \n    class YellowLight:\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tprint(\"Yellow Light -> Changing to Red\")\n    \t\t\t\tlight.state = RedLight()\n    \n    \n    # Context\n    class TrafficLight:\n    \t\tdef __init__(self) -> None:\n    \t\t\t\tstate: TrafficLightState = RedLight()\n    \n    \t\tdef change_state(self) -> None:\n    \t\t\t\tself.state.change(self)\n    ```\n- Chain of Responsibility　　リクエストを異なるオブジェクトの連鎖を通して処理　リクエストの処理方法やその順番の拡張　?\n\t- リクエストのハンドラを簡単に追加/入れ替え可能\n    ```Python\n    class LogLevel(Enum):\n    \t\tINFO = 1\n    \t\tDEBUG = 2\n    \t\tERROR = 3\n    \n    \n    class Logger(Protocol):\n    \t\tlevel: LogLevel\n    \t\t_next_logger: Logger | None\n    \n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tpass\n    \n    \n    # Handler\n    class ConsoleLogger(BaseModel):\n    \t\tlevel: LogLevel\n    \t\t_next_logger: Logger = PrivateAttr()\n    \n    \t\tdef set_next(self, logger: Logger) -> None:\n    \t\t\t\tself._next_logger = logger\n    \t\t\n        # Chain of Responsibility\n    \t\tdef log_message(self, level: LogLevel, message: str) -> None:\n    \t\t\t\tif level >= self.level:\n    \t\t\t\t\t\tself.write(message)\n    \t\t\t\tif self._next_logger:\n    \t\t\t\t\t\tself._next_logger.log_message(level, message)\n    \n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tprint(f\"Standard Console::Logger: {message}\")\n    \n    \n    # ConcreteHandler\n    class ErrorLogger(Logger):\n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tprint(f\"Error Console::Logger: {message}\")\n    \n    \n    class DebugLogger(Logger):\n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tprint(f\"Debug Console::Logger: {message}\n    \n    \n    if __name__ == \"__main__\":\n    \t\terror_logger = ErrorLogger(LogLevel.ERROR)\n    \t\tfile_logger = DebugLogger(LogLevel.DEBUG)\n    \t\tconsole_logger = ConsoleLogger(LogLevol.INFO)\n    \n    \t\terror_logger.set_next(file_logger)\n    \t\tfile_logger.set_next(console_logger)\n    \n    \t\terror_logger.log_message(LogLevel.INFO, \"Infomation\")\n    \t\terror_logger.log_message(Loglevel.DEBUG, \"Debug Message\")\n    \t\terror_logger.log_message(LogLevel.ERROR, \"Error Message\")\n    ```\n- Memento　　生成クラスによって内部状態を保持/修復されるオブジェクト　?\n\t- Originatorによって内部状態を保持/修復可能\n    ```Python\n    # Originator\n    class TextEditor(BaseModel):\n    \t\tcontent:str = \"\"\n    \n    \t\tdef create_memento(self) -> TextMemento:\n    \t\t\t\treturn TextMemento(self.content)\n    \n    \t\tdef restore(self, memento) -> None:\n    \t\t\t\tself.content = memento.content\n    \n    \n    # Memento\n    class TextMemento(BaseModel):\n    \t\tcontent: str\n    \n    \n    # Care Taker: 保管者\n    class History(BaseModel):\n    \t\t_history: list = PrivateAttr(default=[])\n    \n    \t\tdef save_state(self, editor: TextEditor) -> None:\n    \t\t\t\tself._history.append(editor.create_memento())\n    \n    \t\tdef undo(self, editor: TextEditor) -> None:\n    \t\t\t\tif not self._history:\n    \t\t\t\t\t\treturn\n    \n    \t\t\t\tmemento = self._history.pop()\n    \t\t\t\teditor.restore(memento)\n    ```\n- Visitor　　オブジェクト群に外部から操作を追加するクラスのインターフェース　obj群への機能の拡張　?\n\t- オブジェクト構造への操作を簡単に追加可能\n    ```Python\n    # Element\n    class ComputePart(Protocol):\n    \t\tdef accept(self, visitor: ComputerPartVisitor) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Element\n    class KeyBoard:\n    \t\tdef accept(self, visitor: ComputerPartVisitor) -> None:\n    \t\t\t\tvisitor.visit_keyboard(self)\n    \n    \n    class Monitor:\n    \t\tdef accept(self, visitor: ComputerPartVisitor) -> None:\n    \t\t\t\tvisitor.visit_monitor(self)\n    \n    \n    # Visitor\n    class ComputerPartVisitor(Protocol):\n    \t\tdef visit_keyboard(self, keyboard Keyboard) -> None:\n    \t\t\t\tpass\n    \n    \t\tdef visit_monitor(self, monitor: Monitor) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Visitor\n    class ComputerPartDisplayVisitor:\n    \t\tdef visit_keyboard(self, keyboard: Keyboard) -> None:\n    \t\t\t\tprint(\"Displaying Keyboard.\")\n    \n    \t\tdef visit_monitor(self, monitor: Monitor) -> None:\n    \t\t\t\tprint(\"Displaying Monitor.\")\n    ```\n\n# Others\n- ソフトウェアライフサイクル　ソフトウェア作成から廃棄までの一生\n\n## Development Model\n- ウォーターフォールモデル　　開発手順を極力後戻りせず開発するモデル\n- 反復型開発モデル　　要件に優先順位を付けて高優先度の要求から少しずつ開発するモデル\n- スパイラルモデル　　リスク分析とプロトタイピングを反復して渦巻き状にソフトウェアを拡大\n    - ラショナル統一プロセス　　分析設計と実装を行き来するオブジェクト指向開発(ラウンドトリップ)を統合\n- アジャイル開発　　如何に変化に強くなるかを重視した軽量級の反復型開発\n    - XP(eXtreme Programming)　　TDD・ペアプログラミング・リファクタリング・CI/CD・YAGNI\n    - スクラム　　毎日ミーティング(デイリースクラム)・スプリント単位での反復開発などのチーム開発手法\n    - DevOps　　開発(Development)と運用(Operation)を同時並行して行うCD手法\n    - DevSecOps　　DevOpsに加えてセキュリティチェックも同時並行して行うCD手法\n\n## Development Procedure\n1. 要件定義　　開発するソフトウェアの概要を確定　要件/前提条件をまとめる(要求分析)\n2. 外部設計　　要件に必要な処理を分解し整理して記述\n3. 内部設計　　分解した処理の分割構成して実現方法をまとめる\n4. コーディング　　プログラムの作成\n5. テスト　　プログラムが正常に動作するか確認\n6. リリース\n7. 保守・運用　　運用時のバグ修正や機能変更時の追加修正\n\n## 雑多\n\n新しいプログラミング言語を触るときはxUnitを実装してみる\n  \nライブラリのカテゴリ\n- Tier 1 : これを捨てる時はコードを一から書き直す覚悟を持つ「心中する」相手\n- Tier 2 : 差し替えには大きな労力を必要とする「強く依存する」相手\n- Tier 3 : いずれ差し替えることを想定した「依存を軽くする」相手\n  \nユニットテスト/結合テスト/UIテスト\n　プロパティベーステスト　　多様な値を入れてテスト　hypothesis\n　ミューテーションテスト　　ソースコードを変更してテストの強度を測るテスト　mutmut\n  \nアサーション　　常に真であることを前提にした条件文　プログラマのエラーのみに使用\n　外部ソースのデータの正常性などは明示的にプログラム本体でチェック\n　アサーションの失敗をシステムの他の部分で判定すべきではない\n　アサーションを全て削除してもプログラムが正しく動作するように記述するべき\n  \nCI(継続的インテグレーション)　　意味的な統合が上手くいっていないところを見つける仕組み\n　機能ブランチが長くなり込み入ったマージを防ぐため、少なくとも1日1回はmainブランチに統合\n　mainブランチへの統合の頻度を高くする(長い機能ブランチによる込み入ったマージを防ぐため)\nCD(継続的デリバリー)　　ソフトウェアを常にリリース可能な状態にすること　自動テスト\n自己テストとCIとリファクタリングの相乗効果+YAGNIによる補完"}]}]},"uuid":"e7561d8b-1614-4715-a8dc-90594072fbfb","timestamp":"2025-06-11T01:25:33.904Z","toolUseResult":[{"type":"text","text":"# Clean Code\n\n## ファイル(5)\n- 1行80-120文字\n- 1ファイル200-500行\n- 高抽象度 → 低抽象度\n    - 呼び出し関数の直後に呼び出される関数を記述\n- 密接に関連する概念を近い距離・関連しない概念を異なるファイルに記述\n    - 同ファイルにクラスと固有の列挙型や例外クラスを定義\n- オブジェクトの生成と実行を分離(依存関係を一方向にする・生成と実行の責務を分ける)\n    - オブジェクトの生成・設定はmain・AbstractFactory・DIコンテナのみ\n        - DIコンテナ　　(Dependency Injection)コンストラクタを通してクラスに依存性注入\n        - 部分型が変化しやすい上位具象型ではなくインターフェースに依存するようにする\n            - 生成する場合変化しやすい具象型を参照するため生成・設定専用モジュールを用意\n            - 具象型を参照するコードを分離して変更に強くする(OCP)\n\t\t\t\n## クラス(10)\n\n### クラスの方針(3)　　クラスを小さくする\n- クラスの責務(変更の原因)は1つ(SRP)\n- フィールド・メソッドの数は最小限(2)\n    - 全メソッドが全フィールドを満遍なく使う(高凝集)\n    - フィールドとメソッドの対応関係が分かれる場合クラスを分割\n- フィールド・メソッドは原則private・公開する必要がある場合のみpublic\n\n### クラスの原則(7)\n- クラス名が責務を表す\n- メソッド順はpublic → private(高抽象度 → 低抽象度)\n- 特定の領域で使用しないフィールドやメソッドを禁止(2)\n    - ユーザー定義型でないオブジェクトはラップ\n        - 組み込みコレクションをラップして使用しないメソッドを禁止\n        - 外部ライブラリのオブジェクトとエラーをラップして仕様変更の影響をなくす\n    - ユーザー定義型オブジェクトはインターフェースを定義\n- インターフェースを挟んで内部実装を分離(疎結合)\n- 1コンセプトに1例外クラス\n    - メッセージでエラーを判別(例外を分けて処理する場合を除く)\n    - Argsクラスの例外をArgsExceptionにまとめエラーに関するコードを移動(テスト容易性)\n- 機能の羨望(他オブジェクトから他オブジェクトのメンバにアクセス)を行わない(デメテルの法則)\n- コンポーネント間のやり取りはDTO(受信データを格納する責務を持つ不変なオブジェクト)\n\n## 関数(10)\n\n### 関数の方針(2)　　関数を小さくする\n- 関数がたった1つのことを行う\n    - 関数が2つ以上のことを行う場合分割(5)\n        - 重複を抽出\n        - 段落に分けて抽出(SRP)\n        - 制御構文を抽出\n        - 反復処理内の異なる責務の処理を反復自体を分けて分離\n        - コマンドとクエリを分けて抽出(コマンドクエリ責務分離)\n            - コマンド関数は副作用があり戻り値を返さない\n                - コマンド関数を分離して純粋関数を増やす(テスト容易性)\n            - クエリ関数は副作用がなく戻り値を返す\n- 関数の処理をより具体的な複数の関数で表現(2)\n    - 1つの関数に1つの抽象レベルを指定\n        - .append(低抽象度)・get_html(高抽象度)\n    - 高抽象度 → 低抽象度となるto節の並びで読めるようにする\n        - 内容を取り込むため開始内容と終了内容を取り込む→開始内容を取り込むため…\n\t\t\n### 関数の原則(8)\n- 引数は0-3個(2)\n    - 引数が多い場合はパラメータクラス作成\n    - 処理の順序を引数で表現\n        - gradient = saturate_gradient(); reticulate_splines(gradient);\n    - キーワード引数で情報付与\n        - initialize_parameters(n_features=X.shape[1])\n- 2-4行でインデント1つまで\n- 変数の定義は使う直前(変数の寿命を縮める)\n- 処理に変数を用いる場合一時変数を関数化\n    - circle_square = PI * (radius**2) → circle_square(radius)\n- 制御構文は条件・処理を関数化して2行にする\n- 条件分岐は正常処理同士の分岐・正常処理と例外処理の分岐を区別\n    - 条件は肯定・単純・目立つ条件を原則先にする\n    - 比較は左に変化する比較対象\n- 条件分岐の例外処理は早期に戻り値を返す(ガード節)\n    - else節を最小限にする\n- 複雑なif・matchはポリモーフィズム化(Pluggable Object)\n\n## 命名(8)\n\n### 命名の方針(4)　　良い命名が浮かんだ場合積極的に変更\n- 1コンセプト1単語(似た用途の命名は似る・異なる用途の命名は異なる)\n    - DeviceManagerがある場合　ProtocolController→ProtocolManager\n    - .add(book)**≒**add(customer)がある場合　.add(book, index)→.insert(book, index)\n- コマンド関数は副作用・クエリ関数は返すオブジェクトを命名で明確化\n- 名前の長さはスコープの大きさに対応(短いスコープは名前を省略)\n    - Args.ArgumentMarshaler am = booleanArgs.get(arg);\n- 意味を持つ定数・長い式を命名(一時変数)\n    - THREE_DIGITS_PI = 3.14; circle_square = THREE_DIGITS_PI * (radius**2);\n\t\n### 命名の原則(4)　　意図が明確な場合命名は短い方が良い\n- プログラミング用語・ドメイン用語を使用　ex: job_queue\n- 正確な単語選択(get・fetch・download)　ex: get　軽量アクション\n- 属性の追加(3)\n    - 単位(length→chars/start_ms)\n    - 接頭接尾(3)　ex: unsafe_・untrust_・plaintext_・_urlenc\n        - 最大最小　min・max\n        - 範囲(以上以下)　　first・last\n        - 包含排他(以上未満)　　start・end\n    - bool(6)　肯定形\n        - is(状態)\n        - has(所有)\n        - can(可能性)\n        - show(表示)\n        - should(行動の推奨)\n        - enabled(機能のオンオフ)\n- 不要な単語の省略　ex: convert_to_string→to_string　money_amount→money\n\n## コメント(7)　　コードで伝えられない意図を知らせる\n\n### コメントの方針(2)　　コメントを最小限にする(秀逸なコード > コメント)\n公開APIでない限りdocstring不要(コードとともにコメントを修正するのはDRY原則違反)\n- コードで表現不可能な意図の説明　ex: 自明でないアルゴリズム\n    - \\# このデータだとハッシュツリーよりもバイナリツリーの方が40%速かった\n    - NUM_THREADS = 8 # ≥ 2 * num_processesで十分\n- コードの欠陥　ex: # TODO(name): もっと高速なアルゴリズムを使う\n\n### コメント内容(5)　　正確に簡潔に記述\n- 動作を高レベルで説明\n- 処理の正確な記述　ex: 行 → \\n\n- 情報密度の高い用語　ex: 正規化\n- 曖昧な代名詞を避ける\n- 入出力の秀逸な実例\n\n# Test Driven Development(TDD)\nテストコードと実装コードを同時に書くことで実装と改善を繰り返す開発手法\n- ≠ テストファースト　　テストするコードを書く前にテストを書く\n\n## ルール(2)\n- テストが失敗した場合のみ新しいコードを書きその間は新しいテストを書かない\n- 重複を除去\n\n## 手順(5)\n- TODOリストを書く\n    \n    ```Python\n    # test_money.py\n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    # TODO: $5 * 2 = $10\n    ```\n    \n- テストを1つ書く(テストが実行できない場合最小限の空実装を書く)\n    \n    ```Python\n    # test_money.py\n    from src import money\n    \n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    \n    \n    # TODO: $5 * 2 = $10\n    # TODO: amountをprivateにする\n    # TODO:  Dollarの副作用\n    # TODO: Moneyの丸め処理\n    class TestMoney:\n        def test_multiply_dollar(self) -> None:\n            five_dollar = money.Dollar(5) # Error\n            five_dollar.times(2)\n            assert five_dollar.amount == 10\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        amount: int\n    \n        def __init__(self, amount: int) -> None:\n            ...\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n- 全てのテストを実行して1つの失敗を確認(Red)\n    \n    ```Python\n    # test_money.py\n    from src import money\n    \n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    \n    \n    # TODO: $5 * 2 = $10\n    # TODO: amountをprivateにする\n    # TODO:  Dollarの副作用\n    # TODO: Moneyの丸め処理\n    class TestMoney:\n        def test_multiply_dollar(self) -> None:\n            five_dollar = money.Dollar(5)\n            five_dollar.times(2)\n            assert five_dollar.amount == 10 # Red\n    ```\n    \n- テストが成功する最小限の変更\n    \n    ```Python\n    # money.py\n    class Dollar:\n        amount: int = 10 # テストが成功する最小限の変更\n    \n        def __init__(self, amount: int) -> None:\n            ...\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n- 全てのテストを実行して成功を確認(Green)\n    \n    ```Python\n    # test_money.py\n    from src import money\n    \n    # TODO: $5 + 10 CHF = $10 (rate is 2:1)\n    \n    \n    # TODO: $5 * 2 = $10\n    # TODO: amountをprivateにする\n    # TODO:  Dollarの副作用\n    # TODO: Moneyの丸め処理\n    class TestMoney:\n        def test_multiply_dollar(self) -> None:\n            five_dollar = money.Dollar(5)\n            five_dollar.times(2)\n            assert five_dollar.amount == 10 # Green\n    ```\n    \n- 重複を除去(Refactoring)\n    \n    ```Python\n    # money.py\n    class Dollar:\n        amount: int = 5 * 2 # テストの5と2との重複\n    \n        def __init__(self, amount: int) -> None:\n            ...\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = 5 * 2\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount * 2 # 5の重複の削除\n    \n        def times(self, multiplier: int) -> None:\n            ...\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount\n    \n        def times(self, multiplier: int) -> None:\n            self.amount = self.amount * 2\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount\n    \n        def times(self, multiplier: int) -> None:\n            self.amount = self.amount * multiplier　# 2の重複の除去\n    ```\n    \n    ```Python\n    # money.py\n    class Dollar:\n        def __init__(self, amount: int) -> None:\n            self.amount = amount\n    \n        def times(self, multiplier: int) -> None:\n            self.amount *= multiplier # self.amountの重複の除去\n    ```\n    \n## TODOリスト(7)　　実装する最小単位のテストの集まり\n\n### TODOリストに書くテスト(5)\n- 実装しなければならないテスト　ex: $5 + 10 CHF = $10\n- 大きいテストのための最小単位のテスト　ex: $5 + 10 CHF = $10 → Francの掛け算が最小単位\n    - 大きい設計を考える場合まず手前にある小さな設計に着手\n- 疑問・問題点のリファクタリング　ex: 0や空文字列の場合の動作・掛け算の副作用\n- リファクタリングで欲しかったテスト\n- 言語仕様や外部ライブラリの仕様を確認するテスト(学習テスト)\n    - 新バージョンに対しての動作確認が可能\n\t\n### テストの選び方(2)\n- 最も単純なテスト\n- 次のテストに活かせるテスト\n    - 最初は抽象度が高いアプリケーションテストを書く\n        - socketが書き込まれた文字列を返せるかのテスト(後に文字列についてのテストが可能)\n\t\t\n## テスト(14)　　コードの動作を保証する手段\n\n### テストの方針(7)\n- 自分のコードのみテストを書く(他のコードを信頼できない理由がある場合を除く)\n- 1コンセプト1テスト関数\n- 読みやすさ最優先(長い名前・メンタルマッピング(ex: hbChl, …)を許容)\n- テスト同士を独立化(テストの成否が他テストの結果に影響せず好きな順序で実行可能)\n- 上手く機能しないテストは一旦消して引き返す\n- 個人作業終了時は失敗したままのテストを書いておく(次の作業への手がかりにする)\n- テスト量はプロダクトの推定寿命による\n\n### テストの規則(7)\n- 複雑なpublicメソッドにテストを書く\n    - 内部でのみ使うprivateな振る舞いの正しさも保証・単純なpublicメソッドは省略\n- テストの対象を操作・制御構文・ポリモーフィズムに絞る\n- テスト関数名はテストが書かれた理由にする\n- テストメソッドは3行まで\n- アサーションを最初に書く(アサーションファースト)(Assert)(4)\n    - アサーションは原則1つ\n        - 強く関連したアサーションは2つ以上にする(2つ目が検証されない場合がある)\n    - 適切なデータを選ぶ(3)\n        - 意味のある単純なデータ(1つの値が1つの意味を持つ)　ex: 1 + 1 → 1 + 2(順番を明確化)\n        - 明示的なデータ　ex: RATE → 2, COMMISION → 0.015, 49.25 → 100 / 2 * (1 - 0.015)\n        - 本物に近いデータ\n    - 条件を具体化　ex: assert rectangle.area() != 0 → assert rectangle.area() == 1\n    - メソッドの順序は記録用文字列を加算(Log String)\n        - assert test.log == “setup testmethod teardown “\n- テストする処理を書く(Act)(2)\n    - テストする処理は1-2行\n    - コレクションの操作は単数の操作をテストした後コレクションでも動くようにする\n        - assert sum(5)== 5 → assert sum(5, []) == 5 → assert sum([5, 7]) == 12\n- 必要なオブジェクトを作る(Arrange)(4)\n    - 意図を伝えやすい生成方法を選ぶ(直接インスタンス生成するかメソッドを使うか)\n    - 処理が重い・準備に手間が掛かるリソースは決められた結果を返すモック作成(DBなど)\n        - 存在しない外側の機能を使って先に内側の機能を作る\n        - モックの書きにくさが設計の悪さを察知\n    - 稀な例外は特定の振る舞いのみが特別な専用クラス作成(Crush Test Dummy)(FullFileなど)\n    - テスト内の反復処理はパラメトライズ\n\t\n## Red(3)　　テストの失敗(不具合)\n\n### Redの方針(1)\n- Redは1つ以下にする・2つ以上の場合ロールバックして1つに減らす\n\n### Redの修正(2)\n- 書くべきことが分かる場合すぐに実装を書く(明白な実装)\n- 書くべきことがわからない場合や予期しないRedがある場合回帰テスト\n    1. Greenにするための最小限の変更(仮実装)　ex: テストする値をそのまま書く\n    2. 実装とテストの重複を除去　ex: 変数に置き換える\n\t\n## リファクタリング(8)　　テストが通り続ける変更\n\n### リファクタリングの方針(4)\n- 実装とテストの重複を除去(コードの内容を近づけていき一致したところで除去)\n    - テスト数を変えずコードのロジックをシンプルにしてカバレッジを上げる\n- 1度に変更するメソッドは1つのみ\n- 修正のための修正(割り込み)は1回まで\n- 新しい概念のメタファーを考えてリファクタリング?\n\n### テストコードのリファクタリング(2)\n- 重複するテストは自身と読み手への情報が減らない場合に消す\n- 複数のテストが使う共通のオブジェクトはフィクスチャ(setup・teardown)\n    - 異なるフィクスチャを使いたい場合はテストクラス分割　ex: Rectangle(0, 0)と(1, 1)\n\t\n### 実装コードのリファクタリング(2)\n- 何をしているかわからなくなった場合一旦メソッドをインライン化\n    - 処理を具体化してロジックをわかりやすくする\n        - bank.reduce(sum, “USD”) → sum.reduce(bank, “USD”)\n- 一般化の方法がわからない場合2つ目の実例をテスト(三角測量)\n\n## その他のTDD\n- ATDD(受け入れテスト駆動開発)\n    - エンドユーザが求める機能のTDDとそれを成功させるためのTDDの2ループを持つ開発手法\n- BDD(振る舞い駆動開発)\n    - ATDDの外側をエンドユーザと要件を確認してATDDを行う手法\n    - ステークホルダーの視点で振る舞いを説明することでアプリケーションを実装\n\t\n## カバレッジ\n- C0　 全命令を少なくとも1回実行しているか(ステートメントカバレッジ)\n    \n    a = 1\n    \n    ```Python\n    if (a > 0) {\n        print(\"a is positive\")\n    }\n    print(\"End of program\")\n    ```\n    \n- C1　 全条件分岐を少なくとも1回真と偽で実行しているか(ブランチカバレッジ)\n    \n    a = 1, -1\n    \n    ```Python\n    if (a > 0) {\n        print(\"a is positive\")\n    }\n    print(\"End of program\")\n    ```\n    \n- C2　 複合条件含む全条件を少なくとも1回真と偽で実行しているか(条件カバレッジ)\n    \n    (a, b) = (1, 1), (-1, 1), (1, -1), (-1, -1)\n    \n    ```Python\n    if (a > 0 and b > 0) {\n        print(\"a and b are positive\")\n    }\n    print(\"End of program\")\n    ```\n    \n- MD・DC　 複合条件含む全条件が独立して結果に影響を与えるか(修正条件・決定カバレッジ)\n    \n    (a, b, c) = (1, 0, 1), (0, 1, 1), (0, 0, 1), (1, 1, 0)\n    \n    a: (1, 0, 1), (0, 0, 1)\n    \n    b: (0, 1, 1), (0, 0, 1)\n    \n    c: (1, 0, 1), (1, 1, 0)\n    \n    ```Python\n    if ((a > 0 or b > 0)) and c > 0) {\n        print(\"condition met\")\n    }\n    print(\"End of program\")\n    ```\n    \n# Domain Driven Design(DDD)\n\n## DDD実装パターン(軽量DDD)\n- ドメインモデル　　小さな対象領域を独立したオブジェクトのモデルとして整理したモデル\n    - 機能からでなく関心事からドメインモデル作成\n        - 機能の一部として作らない(機能中心に設計して依存関係が生まれる)\n            - 年齢を知りたいという関心事 → 計算するロジックを置く場所として年齢クラス作成\n- ドメインオブジェクト　小さな対象領域のデータとプロセスをまとめたオブジェクト\n    - 非プリミティブ型を用いて必要な制約・関連メソッドのみを持つオブジェクトを設計\n    - Value Object　　値への制約と関連メソッドを持つオブジェクト(データの種類毎に作成)\n        - フィールドは不変(コンストラクタでフィールドを定義してsetterを作らない)\n        - プリミティブ型に制約を課す(int: -21億~21億の範囲・str: 無限長で形式自由・…)\n        - フィールドが全て等しい同型のValue Objectを同一とみなす\n    - Entity　　識別子が等しい同型のValue Objectを同一とみなす可変なValue Object\n    - Collection Object　　コレクションへの制約と関連メソッドを持つオブジェクト\n        - コレクションそのもののgetterは作らず内部のコレクションを閉じ込める\n        - getterを作る場合必要な要素を取り出すメソッドのみを作る\n        - setterを作る場合結果を同じ型の新しいCollection Objectで返す\n    - 区分オブジェクト　　列挙型を用いた区分毎のクラス・オブジェクトを持つオブジェクト\n        - 区分毎のクラス・オブジェクトをフィールドに持ちインターフェースのメソッドを持つ  \n            ```Python\n            class FeeType(Enum):\n                adult = AdultFee()\n                child = ChildFee()\n                senior = SeniorFee()\n            \n            \t\t@property\n                def yen(self) -> Yen:\n                    return self.value.yen()\n            \n                @property\n                def label(self) -> Label:\n                    return self.value.label()\n            \n            if __name__ == \"__main__\":\n            \t\tadultfee: FeeType = FeeType.adult\n            ```\n        - 状態遷移の制約を”遷移元”: set(”遷移先”, …)と表し遷移可能かどうかなどを判定可能\n        - インターフェースで同一視可能なクラス・オブジェクトを扱う場合は区分オブジェクト\n        - インターフェースで利用制限したオブジェクトをクラスに注入する場合はDI(依存性注入)\n\n## ドメインモデル分析設計(ドメインモデリング)\n- ソフトウェアの目的　　人間の役に立つこと　要件(人間のやりたいこと)を実現すること\n- 分析　　要件を理解して整理する(要件の聞き取り・不明点の確認・視覚化・文書化)\n- 設計　　要件をソフトウェアとして実現する方法を考える(パッケージ・クラス・メソッド)\n    - 部分を作りながら全体を組み立てる(ボトムアップ型)\n    - 重要な部分(間違いなく必要な部分)から作る\n    - 具体的な用語・概念の単位でドメインモデルを設計\n    - 例外含む要件の手順それぞれのビジネスルールを列挙してオブジェクト化\n        - ビジネスルール　　起きて良いこと・いけないことの判断と対応のルール\n            - 受注(発生源が外部のヒト)　ビジネスルール: 在庫はあるか・契約に違反しないか\n            - 在庫: 数量パッケージを考える　販売可能数量 -使う→ 数量 -持つ→ 数量単位\n            - 例外の判断材料　予定と実績の記録→差異の判別(予定・実績を用いた差異クラス)\n                - 業務の関心事のパターンp112−120, 125-129\n    - 不足しているドメインオブジェクトを見つけながらドメインモデルに追加していく\n    - 実際にコードを書いてみる → 業務知識を増やして洗練していく\n    - コードを変更する度に設計の改善を考える\n        - ビジネスロジックがドメインモデル以外に含まれていないか\n        - パッケージ図　　全体を俯瞰する図\n        - 業務フロー図　　業務活動を時間軸に沿って図示した図\n            - 活動の主体毎にレーンを並べて情報のやり取りを整理\n\n## ドメインモデルアーキテクチャ\nドメインモデル・プレゼンテーション層(画面)・アプリケーション層(アプリの手続き)・データソース層(DB)で分ける場合ビジネスロジックの記述はドメインモデルのみ\n\n### アプリケーション層(アプリの手続き/進行)　サービスクラス\n- ビジネスロジックが含まれていないかを考える　シンプルに保つ\n- 登録系と参照系に分ける　p160-164\n    - 契約による設計　　サービスを利用する側とサービスを提供する側とで約束ごとを決めて設計をシンプルに保つ設計\n        - Noneを返さない\n        - 状態に依存する場合使う側が事前に確認\n        - 契約を守った上で異常が起きた場合例外を通知\n            - Noneを返す場合があるメソッドの前に確認するプロセスを入れて通常だとNoneがでないようにしてそれでもNoneが出た場合は例外\n- 基本サービスを提供するサービスクラス群と基本サービスを組み合わせる複合サービスを提供するシナリオクラス群作成\n- データベース操作を業務の関心事として捉える\n    - リポジトリ　　ドメインオブジェクトの保管と取り出しが可能な架空の収納場所\n        - 全てのドメインオブジェクトを保管していつでも取り出せる仕組み\n        - メソッド名・パラメータ・戻り値は全て業務の用語で表現\n        - サービスクラスにデータベース操作の詳細を意識させない\n        - インターフェース宣言してデータソース層のクラスで実装\n- リポジトリを用いた業務データの記録と参照はデータベース操作ではなく業務の関心事として記述するための工夫\n\n### データソース層(DB)\n- 適切なデータベース設計をする\n    - 命名・データ型・制約(NOT NULL制約/一意性制約/外部キー制約)\n- 列は全てNOT NULL制約\n    - NULLがどうしても必要なカラムは別テーブルに分けることを検討\n- 記録のタイミングが異なるデータはテーブルを分ける(NULLをなくす)\n- 列の追加はテーブルを追加する\n- データベース　　事実の記録\n    - 記録は変更(UPDATE)を禁止\n        - 取り消しを記録し変更を別の記録として追加(不整合を防ぐ)\n    - 記録の度に状態を更新するテーブルを用意(DELETE → INSERTで状態を更新)\n    - 非同期メッセージング　　記録と更新などの非同期な処理を分散して簡単に処理する方法\n    - イベントソーシング　　事実の記録を基本にして派生する情報を目的別に記録する方式\n        - 厳密な即時性はない\n\n### プレゼンテーション層(画面)\n- 内部の処理は関心事に応じて小さく分ける(タスクベース)\n    - タスクベースのユーザーインターフェース　　用途を特定した小さな単位に分けた画面\n- 画面の表示にはドメインオブジェクト(タスクベース)かビューオブジェクト(何でも画面)を用いる\n    - メインオブジェクトは論理的ビューを持つ(ex: 数字のカンマや千円単位の表示)\n    - 論理的ビュー(段落数, 最も長い段落の文字数のカウント, 最初の段落の20文字だけ表示する…)\n    - 物理的ビュー(ex: <p>で囲む, 段落の先頭を全角1文字で字下げする…)\n        - 文字列の配列で段落表現\n- 場合ごとの表示の違いをドメインオブジェクトで出し分ける\n    - {}件見つかった・見つからなかった\n    - モデルがビューの関心事を持つのではなくモデルで表現できる論理的な状態をビューが利用\n- ドメインオブジェクトも画面も利用者の関心事に焦点を当てるため同一視\n    - 画面の表示と一致したドメインオブジェクト作成\n        - history_idを抜いて表示順にしたHistory)\n    - 変換の複雑さを持ち込むのはドメインオブジェクトに他アプリ形式への依存を作らないため\n        - Web APIのjsonデータの格納でも同様\n        - 画面のデザインとドメインオブジェクトの対応p220-224\n- 例外処理を記述\n\n# Clean Architecture\n\n## ソフトウェアアーキテクチャ　　ソフトウェアの性質を決定する設計方法\n- プログラムの構成要素をどのように組み立てるかのルールは全て同じ\n- 目的　　求められるシステムを構築・保守するための人材の最小化\n\n## アーキテクチャの目的　　保守性・拡張性を高める\n- OO駆動型などを使うのは動作させるためじゃない\n- 優れたアーキテクトは決定しない数を最小化する\n- DBやWebサーバなどの決定を遅延して抽象的にし依存性を低くする\n- 方針と詳細を切り離す\n \n### SOLID原則\nモジュールレベルでの保守性・拡張性向上のための考え方\n- 単一責任の原則(SRP: Single Responsibility Principle)　　モジュールが単一の役割を持つ\n    - 役割の異なるモジュールは分割(Facade)\n        ```Rust\n        // 違反例\n        struct Employee;\n        \n        impl Employee {\n        \t\tfn calculate_pay() -> i32 {} // 経理 -> CFO\n        \t\tfn report_hours() -> i32 {} // 人事 -> COO\n        }\n        ```\n        ```Rust\n        // 改善例\n        struct EmployeeData;\n        \n        trait PayCalculator { // 経理 -> CFO\n        \t\tfn calculate_pay() -> i32;\n        }\n        \n        trait HourReporter { // 人事 -> COO\n        \t\tfn report_hours() -> i32;\n        }\n        \n        struct Employee {\n        \t\tdata: EmployeeData\n        };\n        \n        impl PayCalculator for Employee {\n        \t\tfn calculate_pay() -> i32 {}\n        }\n        \n        impl HourReporter for Employee {\n        \t\tfn report_hours() -> i32 {}\n        }\n        ```\n- 開放閉鎖の原則(OCP: Open-Closed Principle)　　モジュールを変更せず拡張可能\n    - 変更の影響を受けないようにコンポーネントをレベル階層に分ける\n        - 高レベルコンポーネントは低レベルコンポーネントの実装を知らない\n            - コンポーネント間をインターフェース経由にする\n- リスコフの置換原則(LSP: Liskov Substitution Principle)　　上位型を部分型に置換可能\n    - 上位型の全性質を部分型が持っている必要がある\n- インターフェース分離の原則(ISP: Interface Segregation Principle)\n    - 上位型が持つ, 部分型が利用しないメソッドと部分型を分離\n    - 役割毎のインターフェースで各メソッドの依存関係をなくす\n- 依存関係逆転の原則(DIP: Dependency Inversion Principle)\n    - 部分型が上位具象型ではなくインターフェースに依存(標準機能など不変とみなせる型を除く)\n        - 変化しやすい具象型を参照しない\n            - 生成する場合具象型を参照するため生成専用クラス作成(Abstruct Factory)\n        - 抽象コンポーネントと具象コンポーネントを分けると依存性と処理の流れは逆向きになる\n            - インターフェースは依存関係を逆転\n\nコンポーネントレベルでの考え方\n- コンポーネント　　デプロイできる最小単位\n    - コンパイラ言語はバイナリファイル・インタープリタ言語はソースファイル\n- CCP・REP・CRPのバランスを取る必要がある\n\n### 閉鎖性共通の原則(CCP)\n- 変更の理由やタイミングが同じクラスをコンポーネントにまとめる・異なるクラスを分ける\n    - コンポーネントを変更する理由が複数あってはならない(一般化SRP)\n\n### 全再利用の原則(CRP)\n- コンポーネントのモジュールに利用しないモジュールへの依存を強要しない\n    - 密結合していないモジュールをコンポーネントにまとめてはならない\n\n### 再利用・リリース等価の原則(REP)\n- 再利用の単位とリリースの単位は等価\n    - コンポーネント形成モジュールは凝集性がありまとめてリリース可能にする必要がある\n\n### 非循環依存関係の原則(ADP)\n- コンポーネントの依存関係に循環があってはいけない\n    - インターフェースを用いて依存関係逆転(IDP)\n- 循環依存がないと下位コンポーネントからボトムアップに実装できる\n\n### 安定依存の原則(SDP)\n- 安定度の高い方向に依存するようにする(変化しやすいモジュールに依存しない)\n    - 多数コンポーネントから依存されるコンポーネントは変更しづらく安定\n    - 独立コンポーネント　　多数コンポーネントから依存され他コンポーネントに依存しない(外部要因で変更が必要にならない)変更しにくい安定なコンポーネント\n    - 従属コンポーネント　　他コンポーネントに依存されず多数コンポーネントに依存する変更しやすい不安定なコンポーネント\n    - (安定度) = (依存入力数) / (依存入力数 + 依存出力数) [0, 1]\n        - コンポーネント図は安定度が大きいほうが下\n    - (上位コンポーネントの安定度) < (下位コンポーネントの安定度)\n\n### 安定度・抽象度等価の原則(SAP)\n- コンポーネントの抽象度は安定度と同程度でなければならない\n    - (+SDP)抽象度の高い方向に依存するようにする(IDP)\n    - (抽象度) = (インターフェース数) / (クラス数) [0, 1]\n        - 抽象度と安定度の差が小さいほどよい\n    - 下位コンポーネントにインターフェースを実装\n\n# Refactoring\n外部の振る舞いを変更せず内部の実装を変更すること\n- 修正や機能の追加を速める(経済的効果がある)\n\n## 手順\n1. テストを書く\n2. 作業を小さく分割してリファクタリング\n3. リファクタリングが成功する度にcommit\n\n## リファクタリングタイミング(15)\n- 不正確な名前\n- 重複したコード\n- パラメータ数が多い関数\n- グローバルなオブジェクト(グローバル変数・クラス変数・Singleton)\n- 同形式の制御構文\n- (パイプラインが最適な言語における)反復処理\n- 複数の責務・分散した責務を持つ・責務のない変数, 関数, クラス, モジュール\n- 高凝集低結合でないクラス・モジュール\n- 上位型のメソッドが必要ない継承\n- プリミティブ型の濫用\n- 同じクラスでないオブジェクト群\n- mutableオブジェクト\n- getter・setter以外にメソッドを持たないデータクラス\n- 関数に見えるオブジェクトのメソッドが返すオブジェクトへの操作を行う関数(稀に必要)\n- 不吉な臭いを隠すコメント\n\n## リファクタリングの原則(4)\n- 機能の追加とリファクタリングを区別\n- リファクタリングによるトレードオフを意識\n- パフォーマンスを意識する場合まずチューニングしやすく作り段階的に速くする\n- 外部の振る舞いを変更しないカプセル化が重要\n\n## リファクタリングの規則(30)\n\n### コード(5)\n- 命名の変更\n- 文のスライド　　責務の可視化・変数の寿命短縮\n- 処理の置換・削除　　処理の最適化　ex: setterの除去\n- 責務(変数・反復)の分離　　責務の区別(責務毎に段落で分離・共通の変数名を責務毎に変更)\n- アサーションの導入　　常に満たすべき条件の明示\n\n### クラス(15)\n- 変数のカプセル化　　変数の可視性の制限(関数経由の変数参照)\n- プリミティブのカプセル化　　　データと関数間の関係の明示・操作の制限\n- 参照から値への変更　フィールドのimmutable化(オブジェクトの状態変更でなく新規作成)\n- 値から参照への変更　　データの更新(リポジトリによりコピーを作る必要がない)\n- クラスの抽出　　単一責務化・高凝集化\n- クラスのインライン化　　責務のないクラスの除去/処理の具体化\n    - 上手く分割できていないクラス群を再分割\n- フィールドの移動　　データ間の関係の明示\n- ローカル変数のフィールド化　　重複処理の除去\n- 委譲の隠蔽　　委譲先以外への依存関係の除去(アクセスしたクラスのメソッドにメソッドを移動)\n- メソッド・フィールドの引き上げ　　重複の除去(ex: コンストラクタの引き上げ)\n- メソッド・フィールドの押し下げ　　不要な処理の除去\n- スーパークラスの抽出　　重複処理の除去\n- サブクラスの削除　　重複処理の除去(クラスの抽出より先に考慮して変更する場合委譲)\n- 委譲によるサブクラスの置換　　クラス間の低結合化・クラス階層の最適化\n- 委譲によるスーパークラスの置換　　クラス間の低結合化・クラス階層の最適化\n\n### 関数(10)\n- パラメータの変更　　責務の境界線の決定(ex: 値のみを持つかobjそのものを持つか)\n- パラメータクラスの作成　　データ間の関係の明示/パラメータ数の最小化(ex: Value Object)\n- フラグパラメータの除去　　単一責務化\n- 関数の移動　重複処理の除去(関数内関数の移動)・データと関数間の関係の明示(メソッド化)\n- 変数の抽出　　処理への命名(スコープ内のみで意味を持つ場合)\n- 関数の抽出　　単一責務化・処理への命名(スコープ外でも意味を持つ場合)\n- 変数・関数のインライン化　　処理の具体化(上手く分割できていない関数群を再分割)\n- 一時変数の関数化　　副作用の除去(変更可能な場合)・重複処理の除去\n- 定数のパラメータ化　　重複処理の除去\n- コマンドとクエリの分離　　副作用の分離\n- 条件の統合\n- ガード節による条件の置換・逆転　　正常な条件分岐と例外処理の区別\n- ポリモーフィズムによる条件分岐の置換　複雑な条件分岐の除去(上位型とファクトリ関数)\n- ポリモーフィズムによる例外ケースの置換　　例外動作の重複除去(Null Objectパターン)\n- ファクトリ関数によるコンストラクタの置換　　処理への命名・パラメータの多様化\n\n# Programming Paradigm\n\n## Object Oriented Programming(OOP)　　カプセル化とポリモーフィズムを用いる考え方\n- カプセル化　　クラスを用いてデータとデータに関連するプロセスを閉じ込めて外部からの直接アクセスを制限\n    - クラス　　フィールド(データ)とメソッド(プロセス)を合わせて定義するオブジェクトの型\n    - オブジェクト　　クラスを実体化(インスタンス)したもの\n- ポリモーフィズム(多態性)　　クラスの関係性を作り異なるクラスのオブジェクトに同じメソッドを持たせること\n- 部分型　　他のクラス(上位型)を基底として作るクラス　関係性を作る\n    - 集約　　上位型が外部オブジェクトをフィールドに持つこと(has-a)\n        - 他のオブジェクトでも使われる部品\n    - 合成　　上位型が部分型オブジェクトを生成してフィールドに持つこと\n        - そのオブジェクトでしか使われない部品\n        - 部分型が上位型の変更の影響を受けにくい(疎結合)\n        - 委譲　　上位型が内部で部分型のメソッドを実行すること\n- インターフェース　部分型に同じ形式(名前・引数/戻り値の型)のメソッドを持たせる上位型\n    - インターフェースは実装の詳細を持たない\n    - インターフェースは抽象度の高い処理に対して抽象度の低い実装の影響を分離(疎結合)\n    - インターフェースはフィールドに持つオブジェクトのメソッドを制限\n    - プロトコル　　同じメンバを持つ型を部分型として扱うインターフェース(構造的部分型)\n        - クラス間の物理的依存関係を作らない(疎結合)/フィールドの形式も指定可能\n        - 複合プロトコル　　複数のプロトコルを多重継承したプロトコル\n            - 物理的依存関係がないためプロトコルの多重継承は安全\n    - 抽象クラス　　抽象メソッドのみを持つことが保証されるインターフェース(≒Mixin)\n        - 抽象メソッド　　継承により部分型に実装を強制するメソッド\n- 継承　　上位型の全メンバをコピーして部分型を作ること(is-a)　基本非推奨\n    - ユースケース\n        - たった1つのカテゴリのみ異なる振る舞いを持つオブジェクト\n        - 上位型の代わりに部分型が使えるかつどちらも使用する関係を明確にする場合\n        - 親クラスの全メソッドが子クラスにおいて意味を持つ場合(リスコフの置換原則)\n        - 子クラスの全インスタンスが親クラスのインスタンスとして使用する全ての場合で有効な場合\n        - 親クラスが子クラスの情報を持たない場合\n    - 多重継承　　多種類の上位型の継承　複雑性により非推奨\n    - Mixin　　メソッドのみを持つクラスの(多重)継承(**≒抽象クラス)**\n        - フィールドの有無(クラスかMixinか)を区別できない\n- 手続き型とオブジェクト指向はトレードオフ\n    - 手続き型　　既存のデータクラスを変更せず関数を追加可能\n    - オブジェクト指向　　既存の関数を変更せずクラスを追加可能\n- オブジェクトとデータ構造(DTO: データ転送クラス)\n    - オブジェクトはカプセル化を用いてデータを隠蔽しメソッドを通じてのみデータにアクセスを許可\n    - データ構造はデータを公開し外部から直接操作を許可\n    - データを外部から直接操作可能な、メソッドを持つオブジェクトとデータ構造の混血児を作らない\n    - オブジェクトはカプセル化するべきでデータ構造はビジネスロジックをもつべきでないという話\n- AOP(アスペクト指向プログラミング) = デコレータ\n    - クラス間を横断する機能(ログ出力や認証)などのオブジェクト指向では分離できない横断的関心事に対して、別個分離して記述することで重複を防ぐ試み\n\n## Functional Programming(FP)\n以下の特性を持つ式や関数を用いる考え方\n- 変数不変性　　変数の値を変更不可能\n    - =演算子が数学的な等価を表す(≠代入)\n    - 状態ではなく履歴からの計算を随時行えば可変変数は必要ない(イベントソーシング)\n- 参照透過性　　式や関数の構成要素が同じ場合常に同じ値・状態になること\n    - 副作用(関数内で戻り値以外の状態を変更する箇所)をなくす・影響範囲を狭める\n    - 純粋関数　　参照透過な関数(数学的な意味の関数)　並列処理やテストが容易\n- 関数のオブジェクト化　　関数をオブジェクトとして扱う\n    - 関数を引数として処理を変化させるデコレータ(高階関数・コールバック関数)\n    - 外側の関数の引数によって処理を変化させるクロージャ\n- 遅延評価　　演算の実行直前に必要な値の処理を実行すること\n    - 条件分岐などで演算をしない場合必要な値の処理をしないため効率的\n\n# Software Architecture\n\n## Onion Aichitecture\n\n# Software Design\n\n## Design Principle\n\n### DRY原則(Don’t Repeat Yourself)\n- 重複部分を抽象化して排除\n### YAGNI原則(You aren’t going to need it)\n- 今必要な機能のみ実装\n### F.I.R.S.T\n\nクリーンテストの条件\n- Fast(高速)\n- Independent(独立)　　テストの成否が他のテストの結果に影響しない　好きな順序で実行可能\n- Repeatable(再現可能)　　どんな環境でも再現可能\n- Self-Validating(自己検証可能)　　テストは成功か失敗のどちらかのみを出力\n- Timely(適時性)　　テストは必要な場合すぐ書けなければならない\n\n### ケント・ベックの単純な設計のための4つの規則\n- 全テストを実行\n- 重複がない\n- プログラマの意図が表現\n- クラスとメソッドの数を最小化　最も優先度が低い\n\n### デメテルの法則(たまに役立つデメテルの提案)\n\n関数は、関数から見えているオブジェクトのメソッドのみを使用するべきであり、\nそのオブジェクトのメソッドが返すオブジェクトの内部について知るべきではない ≠ データクラス\nクラスCのメソッドfについて、fは次のオブジェクトのメソッドのみを呼び出すべきである\n- Cのメソッド\n- Cのインスタンス変数オブジェクトのメソッド\n- fの引数オブジェクトのメソッド\n- fで生成されたオブジェクトのメソッド\n    - x final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()\n\n### ボーイスカウトの規則\n- 読んだコードを読む前よりもきれいにすること\n\n### ブルックスの法則\n- 遅延プロジェクトに人員を投入しても更に遅らせるだけ\n\n### マーフィーの法則\n- プロジェクトは所要時間を使い切るまで肥大化\n\n### コンウェイの法則\n- システムを設計する組織は組織のコミュニケーション構造と同一の構造の設計を生み出す\n\n## Design Pattern\n### 生成(4)\n- Builder　　生成オブジェクトに具体的な性質を付与するメソッドをもつクラスのインターフェース　objの構成要素の拡張　ラップ\n\t- DirectorがBuilderのメソッドを操作しオブジェクトに性質を付与する　カプセル化\n\t- 新しい、オブジェクトの構成プロセスを簡単に追加可能　疎結合\n    \n    ```Python\n    # Builder\n    class SandwichBuilder(Protocol):\n    \t\tsandwich: Sandwich\n    \n    \t\tdef add_bread(self) -> None:\n    \t\t\t\tpass\n    \n    \t\tdef add_fillings(self) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Builder\n    class VeggieSandwichBuilder:\n    \t\tdef __init__(self) -> None:\n    \t\t\t\tself.sandwich = Sandwich()\n    \n    \t\tdef add_bread(self) -> None:\n    \t\t\t\tself.sandwich.bread = \"grain bread\"\n    \n    \t\tdef add_filling(self) -> None:\n    \t\t\t\tself.sandwich.fillings = \"Tomato\"\n    \n    \n    class ChickenSandwichBuilder:\n    \t\tdef __init__(self):\n    \t\t\t\tself.sandwich = Sandwich()\n    \n    \t\tdef add_bread(self) -> None:\n    \t\t\t\tself.sandwich.bread = \"White bread\"\n    \n    \t\tdef add_fillings(self) -> None:\n    \t\t\t\tself.sandwich.fillings = \"Grilled chicken\"\n    \n    \n    # Director: Builderを使用してオブジェクトを構築\n    class SandwichDirector(BaseModel):\n    \t\tbuilder: Builder\n    \n    \t\tdef make_sandwich(self) -> Sandwich:\n    \t\t\t\tself.builder.add_bread()\n    \t\t\t\tself.builder.add_fillings()\n    \t\t\t\treturn self.builder.sandwich\n    \n    \n    # Product\n    class Sandwich:\n    \t\tdef __init__(self) -> None:\n    \t\t\t\tself.bread = None\n    \t\t\t\tself.fillings = None\n    \t\t\t\t\n    ```\n- Factory Method　　インターフェースによる、具体的なクラスを指定しないオブジェクト生成メソッド　objの種類の拡張\n\t- 新しい種類のクラスを簡単に追加可能　疎結合\n    ```Python\n    # Product\n    class Animal(Protocol):\n    \t\tdef speak(self) -> str:\n    \t\t\t\t...\n    \n    \n    # Concrete Product\n    class Dog:\n    \t\tdef speak(self) -> str:\n    \t\t\t\treturn \"Woof!\"\n    \n    \n    class Cat:\n    \t\tdef speak(self) -> str:\n    \t\t\t\treturn \"Meow!\"\n    \n    \n    \\#Creator: Factory Methodをもつ(インスタンス化させる具体的なクラスは知らない)\n    class AnimalFactory(Protocol):\n    \t\tdef create_animal(self) -> Animal:\n    \t\t\t\t...\n    \n    \n    \\#Concrete Creator: 具体的なFactory Methodをもつ\n    class DogFactory:\n    \t\tdef create_animal(self) -> Animal:\n    \t\t\t\treturn Dog()\n    \n    \n    class CatFactory:\n    \t\tdef create_animal(self) -> Animal:\n    \t\t\t\treturn Cat()\n    ```\n- Abstract Factory　　ある特性をもつオブジェクト群の生成メソッドをもつクラスのインターフェース　objの関連性の拡張\n\t- Factoryが関連するオブジェクトの一括生成による高い結合性を実現\n\t- オブジェクト群の新しい関連性を簡単に追加可能　疎結合\n    ```Python\n    # Abstract Product\n    class Button(Protocol):\n    \t\tdef click(self) -> str:\n    \t\t\t\t...\n    \n    \n    class  CheckBox(Protocol):\n    \t\tdef check(self) -> str:\n    \t\t\t\t...\n    \n    \n    # Concrete Product\n    class DarkButton:\n    \t\tdef click(self) -> str:\n    \t\t\t\treturn \"Dark button clicked!\"\n    \n    \n    class LightButton:\n    \t\tdef click(self) -> str:\n    \t\t\t\treturn \"Light button clicked!\"\n    \n    \n    \n    class DarkCheckBox:\n    \t\tdef check(self) -> str:\n    \t\t\t\treturn \"Dark checkbox checked!\"\n    \n    \n    class LightCheckBox:\n    \t\tdef check(self) -> str:\n    \t\t\t\treturn \"Dark checkbox checked!\"\n    \n    \n    # Abstract Factory\n    class GUIFactory(Protocol):\n    \t\tdef create_button(self) -> Button:\n    \t\t\t\t...\n    \n    \t\tdef create_checkbox(self) -> CheckBox:\n    \t\t\t\t...\n    \n    \n    \\#Concrete Factory\n    class DarkThemeFactory:\n    \t\tdef create_button(self) -> Button:\n    \t\t\t\treturn DarkButton()\n    \n    \t\tdef create_checkbox(self) -> CheckBox:\n    \t\t\t\treturn DarkCheckBox()\n    \n    \n    class LightThemeFactory:\n    \t\tdef create_button(self) -> Button:\n    \t\t\t\treturn LightButton()\n    \n    \t\tdef create_checkbox(self) -> CheckBox:\n    \t\t\t\treturn LightCheckBox()\n    ```\n- Singleton　　生成するインスタンスが全て同一なクラス　カプセル化されたグローバルなデータ　非推奨\n\t- 全体で共有したいデータの管理　カプセル化\n\t- グローバル変数の問題を引き起こす\n    ```Python\n    class Singleton:\n        _instance = None\n    \n        def __new__(cls):\n            if cls._instance is None:\n                cls._instance = super().__new__(cls) \\#instanceをフィールドに保存\n                # 他の初期化処理\n            return cls._instance\n    ```\n### 構造(6)\n- Adapter　　既存オブジェクトであるメンバのメソッドを新しいメソッドで呼び出すことで別のインターフェースに変換するクラス　既存クラスの再利用\n\t- 既存のクラスを変更せず新しいインターフェースで再利用可能　Wrapper\n    ```Python\n    # Target\n    class ThreePinSocket(Protocol):\n    \t\tdef connect_three_pin(self) -> str:\n    \t\t\t\t...\n    \n    \n    # Adaptee\n    class TwoPinPlug:\n    \t\tdef connect_two_pin(self) -> str:\n    \t\t\t\treturn \"2ピンのプラグを接続しました。\"\n    \n    \n    # Adapter\n    class TwoToThreePinAdapter(BaseModel):\n    \t\tplug: TwoPinPlug\n    \n    \t\tdef connect_three_pin(self) -> str:\n    \t\t\t\treturn self.plug.connect_two_pin() + \"３ピンのソケットにアダプタを使用して接続しました。\"\n    ```\n- Facade　　合成により複数クラスを管理する単純なクラス　複数クラスのメソッドの統合\n\t- 複数のクラスを単純なクラスで操作可能(ファサード)\n    ```Python\n    # Subsystem\n    class Amlifier:\n    \t\tdef on(self) -> None:\n    \t\t\t\tprint(\"Amplefier is on\")\n    \n    \t\tdef set_volume(self, level: int) -> None:\n    \t\t\t\tprint(f\"Setting volume to {level}\")\n    \n    \n    class Tuner:\n    \t\tdef set_am(self) -> None:\n    \t\t\t\tprint(\"Setting to AM mode\")\n    \n    \t\tdef set_fm(self) -> None:\n    \t\t\t\tprint(\"Setting to FM mode\")\n    \n    \n    class CDPlayer:\n    \t\tdef play(self, track: int) -> None:\n    \t\t\t\tprint(f\"Playing track {track}\")\n    \n    \n    # Facade\n    class MusicSystemFacade(BaseModel):\n    \t\tamp: Amlifier\n    \t\ttuner: Tuner\n    \t\tcd_player: CDPlayer\n    \n    \t\tdef play_music(self, track: int) -> None:\n    \t\t\t\tself.amp.on()\n    \t\t\t\tself.amp.set_volume(5)\n    \t\t\t\tself.tuner.set_fm()\n    \t\t\t\tself.cd_player.play(track)\n    ```\n- Proxy　　他のオブジェクトへの操作を制御するための代理オブジェクト　objへの操作の制限や追加機能\n\t- オブジェクトへの制御や追加機能を簡単に行える\n    ```Python\n    # Subject\n    class Database(Protocol):\n    \t\tdef request(self) -> None:\n    \t\t\t\tpass\n    \n    \n    # Real Subject\n    class RealDatabase:\n    \t\tdef request(self) -> None:\n    \t\t\t\tprint(\"RealDatabase: Handling the request.\")\n    \n    \n    # Proxy\n    class DatabaseProxy(BaseModel):\n    \t\t_database: Database = PrivateAttr()\n    \n    \t\tdef request(self) -> None:\n    \t\t\t\tif not self._database:\n    \t\t\t\t\t\tself._database = RealDatabase()\n    \t\t\t\tprint(\"Proxy: Forwarding the request to RealDatabase.\")\n    \t\t\t\tself._database.request()\n    ```\n- Imposter　　複数のオブジェクトをまとめそれらのような振る舞いをするオブジェクト(抽象化)\n    - Composite　　個別のオブジェクトとコンテナオブジェクト両方に共通のインターフェース　objと一貫性のあるcontainerの種類の拡張\n\t    - オブジェクトと一貫性のあるcontainerを簡単に追加可能\n        ```Python\n        # Component\n        class FileComponent(Protocol):\n        \t\tname: str\n        \n        \t\tdef show(self) -> None:\n        \t\t\t\tpass\n        \n        \n        # Leaf\n        class FileLeaf(BaseModel):\n        \t\tname: str\n        \n        \t\tdef show(self) -> None:\n        \t\t\t\tprint(f\"File: {self.name}\")\n        \n        \n        # Composite\n        class DirectoryComposite(BaseModel):\n        \t\tname: str\n        \t\t_children: list = PrivateAttr(default=[])\n        \n        \t\tdef add(self, component) -> None:\n        \t\t\t\tself._children.append(component)\n        \n        \t\tdef show(self) -> None:\n        \t\t\t\tprint(f\"Directory: {self.name}\")\n        \t\t\t\tfor child in self.children:\n        \t\t\t\t\t\tchild.show()\n        ```\n- Bridge　　機能と実装を分離するため、実装クラスをメンバにもつ機能クラス　機能と実装の拡張性　?\n\t- 機能と実装の分離により簡単に新しい機能、新しい実装を追加可能\n    ```Python\n    # Abstraction(Bridge): 機能の最上位クラス\n    class Device(BaseModel):\n    \t\timplementor: DeviceImplementor\n    \n    \t\tdef turn_on(self) -> None:\n    \t\t\t\t# 起動の準備　機能\n    \t\t\t\tself.implementor.turn_on()\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\t# 停止の準備　機能\n    \t\t\t\tself.implementor.turn_off()\n    \n    \n    # Refined Abstraction\n    class CleanDevice(BaseModel):\n    \t\t\n    \n    \n    # Implementor: 実装の最上位クラス\n    class DeviceImplementor(Protocol):\n    \t\tdef turn_on(self) -> None:　 # 起動　実装\n    \t\t\t\tpass\n    \n    \t\tdef turn_off(self) -> None:　# 停止　実装\n    \t\t\t\tpass\n    \n    \n    # Concrete Implementor\n    class RadioImplementor:\n    \t\tdef turn_on(self) -> None:\n    \t\t\t\tprint(\"Turn on radio.\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tprint(\"Turn off radio.\")\n    \n    \n    class TBImplementor:\n    \t\tdef turn_on(self) -> None:\n    \t\t\t\tprint(\"Turn on TV.\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tprint(\"Turn off TV.\")\n    ```    \n- Flyweight　　データ構造への参照で新規オブジェクトのかわりに返されるキャッシュオブジェクト　キャッシュによるメモリ節約\n\t- キャッシュによるメモリ節約\n    ```Python\n    # Flyweight\n    class Character(BaseModel):\n    \t\tchar: str\n    \n    \t\tdef display(self, font: str, size: int) -> None:\n    \t\t\t\tprint(f\"Displaying {self.char} in {font} with size {size}\")\n    \n    \n    # FlyweightFactory\n    class CharacterFactory(BaseModel):\n    \t\t_characters: dict = PrivateAttr(default={})\n    \n    \t\tdef get_character(self, char: str) -> dict[str, Character]:\n    \t\t\t\tif char not in self._characters:\n    \t\t\t\t\t\tself._characters[char] = Character(char)\n    \t\t\t\treturn self._characters[char]\n    ```\n### 振る舞い(8)\n- Command　　「1つの処理を表すクラス」のインターフェース　処理の実行のための処理を分離\n\t- 処理の実行のための処理(ex: 処理の記録や遅延処理)と実行を分離\n    ```Python\n    class Command(Protocol):\n    \t\tdef excute(self) -> None:\n    \t\t\t\tpass\n    \n    \n    class LightOnCommand(BaseModel):\n    \t\tlight: Light\n    \n    \t\tdef excute(self) -> None: # 処理の実行のための処理\n    \t\t\t\t...\n    \t\t\t\tself.light.turn_on()\n    \n    \n    class LightOffCommand(Basemodel):\n    \t\tlight: Light\n    \n    \t\tdef excute(self) -> None:\n    \t\t\t\t...\n    \t\t\t\tself.light.turn_off()\n    \n    \n    class Light:\n    \t\tdef turn_on(self) -> None: # 処理の実行\n    \t\t\t\tprint(\"Light is on\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tprint(\"Light is off\")\n    ```\n- Strategy　　アルゴリズムをカプセル化したクラスのインターフェース　実行時のアルゴリズム選択\n\t- アルゴリズムを簡単に追加/選択可能    \n    ```Python\n    # Strategy\n    class SortStrategy(Protocol):\n    \t\tdef sort(self, dataset: list) -> list:\n    \t\t\t\t...\n    \n    \n    # Concrete Starategies\n    class Bubblesort:\n    \t\tdef sort(self, dataset: list) -> list:\n    \t\t\t\tfor i in range(num_dataset := len(dataset)):\n    \t\t\t\t\t\tfor j in range(num_dataset-i-1):\n    \t\t\t\t\t\t\t\tif dataset[j] > dataset[j+1]:\n    \t\t\t\t\t\t\t\t\t\tdataset[j], dataset[j+1] = dataset[j+1], dataset[j]\n    \t\t\t\treturn dataset\n    \n    \n    class QuickSort:\n    \t\tdef sort(self, dataset: list) -> list:\n    \t\t\t\tnum_dataset = len(dataset)\n    \t\t\t\tif num_dataset <= 1:\n    \t\t\t\t\t\treturn dataset\n    \t\t\t\tpivot = dataset[len(dataset) // 2]\n    \t\t\t\tleft = [x for x in dataset  if x < pivot]\n    \t\t\t\tmiddle = [x for x in dataset if x == pivot]\n    \t\t\t\tright = [x for x in dataset if x > pivot]\n    \t\t\t\treturn self.sort(left) + middle + self.sort(right)\n    \n    \n    # Context\n    class SortContext(BaseModel):\n    \t\tstrategy: SortStrategy\n    \n    \t\tdef excute_sort(self, dataset: list) -> list:\n    \t\t\t\treturn self.strategy.sort(dataset)\n    ```\n- Mediator　　通信を行うオブジェクトの操作を行うクラスのインターフェース　通信の拡張　?\n\t- 通信を行うオブジェクトの管理を集中することで通信を簡単に拡張可能\n    ```Python\n    # Mediator: 仲介者\n    class Mediator(Protocol):\n    \t\tdef notify(self, sender: Room, event: str) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Mediator\n    class LightMediator(BaseModel):\n    \t\t_rooms: dict = PrivateAttr(default={})\n    \n    \t\tdef add_room(self, room: Room) -> None:\n    \t\t\t\tself.rooms[room.name] = room\n    \n    \t\tdef notify(self, sender: Room, event: str) -> None:\n    \t\t\t\tif event == \"ON\":\n    \t\t\t\t\t\tfor room_name, room in self.rooms.items():\n    \t\t\t\t\t\t\t\tif room_name != sender.name:\n    \t\t\t\t\t\t\t\t\t\troom.turn_off()\n    \n    \n    # Colleague\n    class Room(BaseModel):\n    \t\tname: str\n    \t\tmediator: Mediator\n    \t\tlight: str = \"OFF\"\n    \n    \t\tdef turn_on(self) -> None:\n    \t\t\t\tself.light = \"ON\"\n    \t\t\t\tself.mediator.notify(self, \"ON\")\n    \t\t\t\tprint(f\"{self.name} light is ON\")\n    \n    \t\tdef turn_off(self) -> None:\n    \t\t\t\tself.light = \"OFF\"\n    \t\t\t\tprint(f\"{self.name} light is OFF\")\n    ```\n- Observer　　あるオブジェクトの状態変化を通知するクラスのインターフェース　通知の種類の拡張　?　処理フローがおいにくい\n\t- 状態変化により変化する通知オブジェクトの操作クラスを分離することで通知を新しく追加可能\n    ```Python\n    # Subject\n    class NewsService(BaseModel):\n    \t\t_observers: list = PrivateAttr(default=[])\n    \t\t_news: str | None = PrivateAttr(default=None)\n    \n    \t\tdef add_observer(self, observer: Subscriber) -> None:\n    \t\t\t\tself._observers.append(observer)\n    \n    \t\tdef remove_observer(self, observer: Subscriber) -> None:\n    \t\t\t\tself._observers.remove(observer)\n    \n    \t\tdef notify_observers(self) -> None:\n    \t\t\t\tfor observer in self._observers:\n    \t\t\t\t\t\tobserver.update(self._news)\n    \n    \t\tdef add_news(self, news: str) -> None:\n    \t\t\t\tself._news = news\n    \t\t\t\tself.notiry_observers()\n    \n    \n    # Observer\n    class Subscriber(Protocol):\n    \t\tdef update(self, news: str) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Observer\n    class EmailSubscriber:\n    \t\tdef update(self, news: str) -> None\n    \t\t\t\tprint(f\"Email: New news published - {news}\")\n    \n    \n    class SmsSubscriber:\n    \t\tdef update(self, news: str) -> None:\n    \t\t\t\tprint(f\"SNS: New news published - {news}\")\n    ```\n- State　　オブジェクトの内部状態を変更するクラスのインターフェース　内部状態に応じて動作を変更　?\n\t- 状態遷移のロジックを明確にして状態変更の種類を簡単に追加可能　\n    ```Python\n    # 　State\n    class TrafficLightState(Protocol):\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete State\n    class RedLight:\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tprint(\"Red Light -> Changing to Green\")\n    \t\t\t\tlight.state = GreenLight()\n    \n    \n    class GreenLight:\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tprint(\"Green Light -> Changing to Yellow\")\n    \t\t\t\tlight.state = YellowLight()\n    \n    \n    class YellowLight:\n    \t\tdef change(self, light: TrafficLight) -> None:\n    \t\t\t\tprint(\"Yellow Light -> Changing to Red\")\n    \t\t\t\tlight.state = RedLight()\n    \n    \n    # Context\n    class TrafficLight:\n    \t\tdef __init__(self) -> None:\n    \t\t\t\tstate: TrafficLightState = RedLight()\n    \n    \t\tdef change_state(self) -> None:\n    \t\t\t\tself.state.change(self)\n    ```\n- Chain of Responsibility　　リクエストを異なるオブジェクトの連鎖を通して処理　リクエストの処理方法やその順番の拡張　?\n\t- リクエストのハンドラを簡単に追加/入れ替え可能\n    ```Python\n    class LogLevel(Enum):\n    \t\tINFO = 1\n    \t\tDEBUG = 2\n    \t\tERROR = 3\n    \n    \n    class Logger(Protocol):\n    \t\tlevel: LogLevel\n    \t\t_next_logger: Logger | None\n    \n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tpass\n    \n    \n    # Handler\n    class ConsoleLogger(BaseModel):\n    \t\tlevel: LogLevel\n    \t\t_next_logger: Logger = PrivateAttr()\n    \n    \t\tdef set_next(self, logger: Logger) -> None:\n    \t\t\t\tself._next_logger = logger\n    \t\t\n        # Chain of Responsibility\n    \t\tdef log_message(self, level: LogLevel, message: str) -> None:\n    \t\t\t\tif level >= self.level:\n    \t\t\t\t\t\tself.write(message)\n    \t\t\t\tif self._next_logger:\n    \t\t\t\t\t\tself._next_logger.log_message(level, message)\n    \n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tprint(f\"Standard Console::Logger: {message}\")\n    \n    \n    # ConcreteHandler\n    class ErrorLogger(Logger):\n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tprint(f\"Error Console::Logger: {message}\")\n    \n    \n    class DebugLogger(Logger):\n    \t\tdef write(self, message: str) -> None:\n    \t\t\t\tprint(f\"Debug Console::Logger: {message}\n    \n    \n    if __name__ == \"__main__\":\n    \t\terror_logger = ErrorLogger(LogLevel.ERROR)\n    \t\tfile_logger = DebugLogger(LogLevel.DEBUG)\n    \t\tconsole_logger = ConsoleLogger(LogLevol.INFO)\n    \n    \t\terror_logger.set_next(file_logger)\n    \t\tfile_logger.set_next(console_logger)\n    \n    \t\terror_logger.log_message(LogLevel.INFO, \"Infomation\")\n    \t\terror_logger.log_message(Loglevel.DEBUG, \"Debug Message\")\n    \t\terror_logger.log_message(LogLevel.ERROR, \"Error Message\")\n    ```\n- Memento　　生成クラスによって内部状態を保持/修復されるオブジェクト　?\n\t- Originatorによって内部状態を保持/修復可能\n    ```Python\n    # Originator\n    class TextEditor(BaseModel):\n    \t\tcontent:str = \"\"\n    \n    \t\tdef create_memento(self) -> TextMemento:\n    \t\t\t\treturn TextMemento(self.content)\n    \n    \t\tdef restore(self, memento) -> None:\n    \t\t\t\tself.content = memento.content\n    \n    \n    # Memento\n    class TextMemento(BaseModel):\n    \t\tcontent: str\n    \n    \n    # Care Taker: 保管者\n    class History(BaseModel):\n    \t\t_history: list = PrivateAttr(default=[])\n    \n    \t\tdef save_state(self, editor: TextEditor) -> None:\n    \t\t\t\tself._history.append(editor.create_memento())\n    \n    \t\tdef undo(self, editor: TextEditor) -> None:\n    \t\t\t\tif not self._history:\n    \t\t\t\t\t\treturn\n    \n    \t\t\t\tmemento = self._history.pop()\n    \t\t\t\teditor.restore(memento)\n    ```\n- Visitor　　オブジェクト群に外部から操作を追加するクラスのインターフェース　obj群への機能の拡張　?\n\t- オブジェクト構造への操作を簡単に追加可能\n    ```Python\n    # Element\n    class ComputePart(Protocol):\n    \t\tdef accept(self, visitor: ComputerPartVisitor) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Element\n    class KeyBoard:\n    \t\tdef accept(self, visitor: ComputerPartVisitor) -> None:\n    \t\t\t\tvisitor.visit_keyboard(self)\n    \n    \n    class Monitor:\n    \t\tdef accept(self, visitor: ComputerPartVisitor) -> None:\n    \t\t\t\tvisitor.visit_monitor(self)\n    \n    \n    # Visitor\n    class ComputerPartVisitor(Protocol):\n    \t\tdef visit_keyboard(self, keyboard Keyboard) -> None:\n    \t\t\t\tpass\n    \n    \t\tdef visit_monitor(self, monitor: Monitor) -> None:\n    \t\t\t\tpass\n    \n    \n    # Concrete Visitor\n    class ComputerPartDisplayVisitor:\n    \t\tdef visit_keyboard(self, keyboard: Keyboard) -> None:\n    \t\t\t\tprint(\"Displaying Keyboard.\")\n    \n    \t\tdef visit_monitor(self, monitor: Monitor) -> None:\n    \t\t\t\tprint(\"Displaying Monitor.\")\n    ```\n\n# Others\n- ソフトウェアライフサイクル　ソフトウェア作成から廃棄までの一生\n\n## Development Model\n- ウォーターフォールモデル　　開発手順を極力後戻りせず開発するモデル\n- 反復型開発モデル　　要件に優先順位を付けて高優先度の要求から少しずつ開発するモデル\n- スパイラルモデル　　リスク分析とプロトタイピングを反復して渦巻き状にソフトウェアを拡大\n    - ラショナル統一プロセス　　分析設計と実装を行き来するオブジェクト指向開発(ラウンドトリップ)を統合\n- アジャイル開発　　如何に変化に強くなるかを重視した軽量級の反復型開発\n    - XP(eXtreme Programming)　　TDD・ペアプログラミング・リファクタリング・CI/CD・YAGNI\n    - スクラム　　毎日ミーティング(デイリースクラム)・スプリント単位での反復開発などのチーム開発手法\n    - DevOps　　開発(Development)と運用(Operation)を同時並行して行うCD手法\n    - DevSecOps　　DevOpsに加えてセキュリティチェックも同時並行して行うCD手法\n\n## Development Procedure\n1. 要件定義　　開発するソフトウェアの概要を確定　要件/前提条件をまとめる(要求分析)\n2. 外部設計　　要件に必要な処理を分解し整理して記述\n3. 内部設計　　分解した処理の分割構成して実現方法をまとめる\n4. コーディング　　プログラムの作成\n5. テスト　　プログラムが正常に動作するか確認\n6. リリース\n7. 保守・運用　　運用時のバグ修正や機能変更時の追加修正\n\n## 雑多\n\n新しいプログラミング言語を触るときはxUnitを実装してみる\n  \nライブラリのカテゴリ\n- Tier 1 : これを捨てる時はコードを一から書き直す覚悟を持つ「心中する」相手\n- Tier 2 : 差し替えには大きな労力を必要とする「強く依存する」相手\n- Tier 3 : いずれ差し替えることを想定した「依存を軽くする」相手\n  \nユニットテスト/結合テスト/UIテスト\n　プロパティベーステスト　　多様な値を入れてテスト　hypothesis\n　ミューテーションテスト　　ソースコードを変更してテストの強度を測るテスト　mutmut\n  \nアサーション　　常に真であることを前提にした条件文　プログラマのエラーのみに使用\n　外部ソースのデータの正常性などは明示的にプログラム本体でチェック\n　アサーションの失敗をシステムの他の部分で判定すべきではない\n　アサーションを全て削除してもプログラムが正しく動作するように記述するべき\n  \nCI(継続的インテグレーション)　　意味的な統合が上手くいっていないところを見つける仕組み\n　機能ブランチが長くなり込み入ったマージを防ぐため、少なくとも1日1回はmainブランチに統合\n　mainブランチへの統合の頻度を高くする(長い機能ブランチによる込み入ったマージを防ぐため)\nCD(継続的デリバリー)　　ソフトウェアを常にリリース可能な状態にすること　自動テスト\n自己テストとCIとリファクタリングの相乗効果+YAGNIによる補完"}]}
{"parentUuid":"e7561d8b-1614-4715-a8dc-90594072fbfb","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","message":{"id":"msg_019VnSZ6pgRJc2nYpyYHAMtB","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"**Obsidian Coding Guidelineの概要**\n\n## 主要なトピック\n\n### 1. Clean Code（クリーンコード）\n- **ファイル構成**: 1行80-120文字、1ファイル200-500行\n- **高抽象度→低抽象度**の順序で記述\n- **オブジェクトの生成と実行を分離**（DIコンテナ活用）\n\n### 2. クラス設計原則\n- **単一責任の原則（SRP）**: 1つの責務のみ持つ\n- **高凝集**: 全メソッドが全フィールドを満遍なく使用\n- **インターフェースを活用**した疎結合設計\n\n### 3. 関数設計\n- **関数を小さく**: 1つのことのみ実行\n- **引数は0-3個まで**（多い場合はパラメータクラス作成）\n- **2-4行でインデント1つまで**\n- **早期リターン（ガード節）**で例外処理\n\n### 4. 命名規則\n- **1コンセプト1単語**\n- **意図が明確**で簡潔な命名\n- **プログラミング用語・ドメイン用語**を使用\n\n### 5. Test Driven Development（TDD）\n- **Red-Green-Refactor**サイクル\n- **テストコードと実装コードを同時開発**\n- **TODOリストでテスト管理**\n\n### 6. Domain Driven Design（DDD）\n- **Value Object**: 値への制約と関連メソッド\n- **Entity**: 識別子による同一性判定\n- **リポジトリパターン**でデータアクセス抽象化\n\n### 7. Clean Architecture\n- **SOLID原則**の遵守\n- **依存関係逆転**によるモジュール間疎結合\n- **方針と詳細の分離**\n\n### 8. リファクタリング\n- **外部振る舞いを変更せず内部実装改善**\n- **小さく分割して段階的に実施**\n- **テスト成功毎にcommit**\n\n### 9. 設計パターン\n- **生成パターン**: Builder, Factory Method, Abstract Factory\n- **構造パターン**: Adapter, Facade, Proxy\n- **振る舞いパターン**: Command, Strategy, Observer\n\n### 10. 開発手法・原則\n- **YAGNI原則**: 今必要な機能のみ実装\n- **DRY原則**: 重複排除\n- **アジャイル開発**: 変化に強い軽量な反復開発\n\nこのガイドラインは、保守性・拡張性の高いコードを書くための包括的な指針となっています。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":23365,"cache_read_input_tokens":18532,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CQ1ZZob86824LaqCJG7Nv","type":"assistant","uuid":"67ee2a8f-4376-4db6-9d81-a506f0d47eec","timestamp":"2025-06-11T01:25:52.531Z"}
{"parentUuid":"65df9ea8-db2f-4d19-be9a-249e2e2e7428","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":"<command-name>exit</command-name>\n            <command-message>exit</command-message>\n            <command-args></command-args>"},"uuid":"41aca745-481a-4631-93ae-9cb8268b7f4c","timestamp":"2025-06-11T01:26:14.251Z"}
{"parentUuid":"41aca745-481a-4631-93ae-9cb8268b7f4c","isSidechain":false,"userType":"external","cwd":"/Users/kaito/dev/py/fix-md-for-obsidian","sessionId":"27e206fc-c9ad-4c58-a6f8-f61dd979c35a","version":"1.0.18","type":"user","message":{"role":"user","content":"<local-command-stdout>(no content)</local-command-stdout>"},"uuid":"98ee81da-7b6c-4764-b672-404fd10e6ba7","timestamp":"2025-06-11T01:26:14.251Z"}
